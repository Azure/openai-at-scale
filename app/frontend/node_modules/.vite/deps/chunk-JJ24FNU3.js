import {
  AnimationClassNames,
  Async,
  Customizer,
  FocusRectsProvider,
  FontWeights,
  HighContrastSelector,
  KeyCodes,
  Rectangle,
  ZIndexes,
  assign,
  classNamesFunction,
  createTheme,
  css,
  divProperties,
  doesElementContainFocus,
  elementContains,
  focusAsync,
  focusClear,
  focusFirstChild,
  getDocument,
  getFirstTabbable,
  getGlobalClassNames,
  getHighContrastNoAdjustStyle,
  getIcon,
  getId,
  getInitials,
  getLastTabbable,
  getNativeProps,
  getNextElement,
  getPropsWithDefaults,
  getRTL,
  getScrollbarWidth,
  getWindow,
  hasOverflow,
  hiddenContentStyle,
  htmlElementProperties,
  imgProperties,
  initializeComponentRef,
  memoizeFunction,
  mergeStyleSets,
  mergeStyles,
  modalize,
  noWrap,
  normalize,
  on,
  portalContainsElement,
  setPortalAttribute,
  setVersion,
  setVirtualParent,
  shallowCompare,
  styled,
  useIsomorphicLayoutEffect,
  warn,
  warnConditionallyRequiredProps,
  warnControlledUsage,
  warnDeprecations,
  warnMutuallyExclusive
} from "./chunk-T6AX7RXF.js";
import {
  __assign,
  __extends,
  __rest,
  __spreadArray
} from "./chunk-YSMJTNBI.js";
import {
  require_react_dom
} from "./chunk-4VE7W7SZ.js";
import {
  require_react
} from "./chunk-Y2Z4LR3N.js";
import {
  __toESM
} from "./chunk-GKWPUQBP.js";

// node_modules/@fluentui/react/lib/components/Persona/Persona.base.js
var React37 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.base.js
var React29 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Callout/Callout.js
var React26 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.base.js
var React21 = __toESM(require_react());

// node_modules/@fluentui/react/lib/common/DirectionalHint.js
var DirectionalHint = {
  /**
   * Appear above the target element, with the left edges of the callout and target aligning.
   */
  topLeftEdge: 0,
  /**
   * Appear above the target element, with the centers of the callout and target aligning.
   */
  topCenter: 1,
  /**
   * Appear above the target element, with the right edges of the callout and target aligning.
   */
  topRightEdge: 2,
  /**
   * Appear above the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  topAutoEdge: 3,
  /**
   * Appear below the target element, with the left edges of the callout and target aligning.
   */
  bottomLeftEdge: 4,
  /**
   * Appear below the target element, with the centers of the callout and target aligning.
   */
  bottomCenter: 5,
  /**
   * Appear below the target element, with the right edges of the callout and target aligning.
   */
  bottomRightEdge: 6,
  /**
   * Appear below the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  bottomAutoEdge: 7,
  /**
   * Appear to the left of the target element, with the top edges of the callout and target aligning.
   */
  leftTopEdge: 8,
  /**
   * Appear to the left of the target element, with the centers of the callout and target aligning.
   */
  leftCenter: 9,
  /**
   * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
   */
  leftBottomEdge: 10,
  /**
   * Appear to the right of the target element, with the top edges of the callout and target aligning.
   */
  rightTopEdge: 11,
  /**
   * Appear to the right of the target element, with the centers of the callout and target aligning.
   */
  rightCenter: 12,
  /**
   * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
   */
  rightBottomEdge: 13
};

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.types.js
var RectangleEdge;
(function(RectangleEdge2) {
  RectangleEdge2[RectangleEdge2["top"] = 1] = "top";
  RectangleEdge2[RectangleEdge2["bottom"] = -1] = "bottom";
  RectangleEdge2[RectangleEdge2["left"] = 2] = "left";
  RectangleEdge2[RectangleEdge2["right"] = -2] = "right";
})(RectangleEdge || (RectangleEdge = {}));
var Position;
(function(Position2) {
  Position2[Position2["top"] = 0] = "top";
  Position2[Position2["bottom"] = 1] = "bottom";
  Position2[Position2["start"] = 2] = "start";
  Position2[Position2["end"] = 3] = "end";
})(Position || (Position = {}));

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.js
var _a;
function _createPositionData(targetEdge, alignmentEdge, isAuto) {
  return {
    targetEdge,
    alignmentEdge,
    isAuto
  };
}
var DirectionalDictionary = (_a = {}, _a[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, void 0, true), _a[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, void 0, true), _a[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a);
function _isRectangleWithinBounds(rect, boundingRect) {
  if (rect.top < boundingRect.top) {
    return false;
  }
  if (rect.bottom > boundingRect.bottom) {
    return false;
  }
  if (rect.left < boundingRect.left) {
    return false;
  }
  if (rect.right > boundingRect.right) {
    return false;
  }
  return true;
}
function _getOutOfBoundsEdges(rect, boundingRect) {
  var outOfBounds = [];
  if (rect.top < boundingRect.top) {
    outOfBounds.push(RectangleEdge.top);
  }
  if (rect.bottom > boundingRect.bottom) {
    outOfBounds.push(RectangleEdge.bottom);
  }
  if (rect.left < boundingRect.left) {
    outOfBounds.push(RectangleEdge.left);
  }
  if (rect.right > boundingRect.right) {
    outOfBounds.push(RectangleEdge.right);
  }
  return outOfBounds;
}
function _getEdgeValue(rect, edge) {
  return rect[RectangleEdge[edge]];
}
function _setEdgeValue(rect, edge, value) {
  rect[RectangleEdge[edge]] = value;
  return rect;
}
function _getCenterValue(rect, edge) {
  var edges = _getFlankingEdges(edge);
  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
}
function _getRelativeEdgeValue(edge, value) {
  if (edge > 0) {
    return value;
  } else {
    return value * -1;
  }
}
function _getRelativeRectEdgeValue(edge, rect) {
  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
}
function _getRelativeEdgeDifference(rect, hostRect, edge) {
  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
  return _getRelativeEdgeValue(edge, edgeDifference);
}
function _moveEdge(rect, edge, newValue, maintainSize) {
  if (maintainSize === void 0) {
    maintainSize = true;
  }
  var difference = _getEdgeValue(rect, edge) - newValue;
  var returnRect = _setEdgeValue(rect, edge, newValue);
  if (maintainSize) {
    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
  }
  return returnRect;
}
function _alignEdges(rect, target, edge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
}
function _alignOppositeEdges(rect, target, targetEdge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var oppositeEdge = targetEdge * -1;
  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
}
function _isEdgeInBounds(rect, bounds, edge) {
  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
}
function _getOutOfBoundsDegree(rect, bounds) {
  var breakingEdges = _getOutOfBoundsEdges(rect, bounds);
  var total = 0;
  for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {
    var edge = breakingEdges_1[_i];
    total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);
  }
  return total;
}
function _flipToFit(rect, target, bounding, positionData, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var directions = [
    RectangleEdge.left,
    RectangleEdge.right,
    RectangleEdge.bottom,
    RectangleEdge.top
  ];
  if (getRTL()) {
    directions[0] *= -1;
    directions[1] *= -1;
  }
  var currentEstimate = rect;
  var currentEdge = positionData.targetEdge;
  var currentAlignment = positionData.alignmentEdge;
  var oobDegree;
  var bestEdge = currentEdge;
  var bestAlignment = currentAlignment;
  for (var i = 0; i < 4; i++) {
    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
      var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);
      if (!oobDegree || currentOOBDegree < oobDegree) {
        oobDegree = currentOOBDegree;
        bestEdge = currentEdge;
        bestAlignment = currentAlignment;
      }
      directions.splice(directions.indexOf(currentEdge), 1);
      if (directions.length > 0) {
        if (directions.indexOf(currentEdge * -1) > -1) {
          currentEdge = currentEdge * -1;
        } else {
          currentAlignment = currentEdge;
          currentEdge = directions.slice(-1)[0];
        }
        currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
      }
    } else {
      return {
        elementRectangle: currentEstimate,
        targetEdge: currentEdge,
        alignmentEdge: currentAlignment
      };
    }
  }
  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);
  return {
    elementRectangle: currentEstimate,
    targetEdge: bestEdge,
    alignmentEdge: bestAlignment
  };
}
function _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {
  var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;
  var oppositeEdge = alignmentEdge * -1;
  var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);
  return {
    elementRectangle: newEstimate,
    targetEdge,
    alignmentEdge: oppositeEdge
  };
}
function _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;
  var elementEstimate = {
    elementRectangle: element,
    targetEdge: positionData.targetEdge,
    alignmentEdge
  };
  if (!directionalHintFixed && !coverTarget) {
    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);
  }
  var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);
  var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : void 0;
  if (outOfBounds.length > 0) {
    if (alignTargetEdge) {
      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
        var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);
        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
          return flippedElementEstimate;
        } else {
          elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);
        }
      } else {
        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
      }
    } else {
      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
    }
  }
  return elementEstimate;
}
function _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {
  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {
    var direction = outOfBoundsEdges_1[_i];
    var edgeAttempt = void 0;
    if (preserveEdge && preserveEdge === direction * -1) {
      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);
      elementEstimate.forcedInBounds = true;
    } else {
      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
      var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);
      if (!inBounds) {
        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);
        elementEstimate.forcedInBounds = true;
      }
    }
    elementEstimate.elementRectangle = edgeAttempt;
  }
  return elementEstimate;
}
function _centerEdgeToPoint(rect, edge, point) {
  var positiveEdge = _getFlankingEdges(edge).positiveEdge;
  var elementMiddle = _getCenterValue(rect, edge);
  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
}
function _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);
  var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  estimatedElementPosition = coverTarget ? _alignEdges(estimatedElementPosition, target, targetEdge, gap) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);
  if (!alignmentEdge) {
    var targetMiddlePoint = _getCenterValue(target, targetEdge);
    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
  } else {
    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
  }
  return estimatedElementPosition;
}
function _getFlankingEdges(edge) {
  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
    return {
      positiveEdge: RectangleEdge.left,
      negativeEdge: RectangleEdge.right
    };
  } else {
    return {
      positiveEdge: RectangleEdge.top,
      negativeEdge: RectangleEdge.bottom
    };
  }
}
function _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {
  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {
    return returnEdge * -1;
  }
  return returnEdge;
}
function _isEdgeOnBounds(elementRectangle, edge, bounds) {
  return bounds !== void 0 && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);
}
function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {
  var returnValue = {};
  var hostRect = _getRectangleFromElement(hostElement);
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {
    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);
  }
  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
  if (forceWithinBounds) {
    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);
    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);
  }
  return returnValue;
}
function _calculateActualBeakWidthInPixels(beakWidth) {
  return Math.sqrt(beakWidth * beakWidth * 2);
}
function _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {
  if (directionalHint === void 0) {
    directionalHint = DirectionalHint.bottomAutoEdge;
  }
  if (previousPositions) {
    return {
      alignmentEdge: previousPositions.alignmentEdge,
      isAuto: previousPositions.isAuto,
      targetEdge: previousPositions.targetEdge
    };
  }
  var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);
  if (getRTL()) {
    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
    }
    return directionalHintForRTL !== void 0 ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
  }
  return positionInformation;
}
function _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {
  if (positionData.isAuto) {
    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
  }
  positionData.alignTargetEdge = alignTargetEdge;
  return positionData;
}
function getClosestEdge(targetEdge, target, boundingRect) {
  var targetCenter = _getCenterValue(target, targetEdge);
  var boundingCenter = _getCenterValue(boundingRect, targetEdge);
  var _a4 = _getFlankingEdges(targetEdge), positiveEdge = _a4.positiveEdge, negativeEdge = _a4.negativeEdge;
  if (targetCenter <= boundingCenter) {
    return positiveEdge;
  } else {
    return negativeEdge;
  }
}
function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
    return {
      elementRectangle: estimatedElementPosition,
      targetEdge: positionData.targetEdge,
      alignmentEdge: positionData.alignmentEdge
    };
  } else {
    return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);
  }
}
function _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {
  var targetEdge = elementPosition.targetEdge * -1;
  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
  var returnValue = {};
  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);
  var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);
  var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));
  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
  return {
    elementPosition: __assign({}, returnValue),
    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
    targetEdge,
    hideBeak: !showBeak
  };
}
function _positionBeak(beakWidth, elementPosition) {
  var target = elementPosition.targetRectangle;
  var _a4 = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a4.positiveEdge, negativeEdge = _a4.negativeEdge;
  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);
  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);
  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);
  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);
  }
  return beakPosition;
}
function _getRectangleFromElement(element) {
  var clientRect = element.getBoundingClientRect();
  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
}
function _getRectangleFromIRect(rect) {
  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
}
function _getTargetRect(bounds, target) {
  var targetRectangle;
  if (target) {
    if (!!target.preventDefault) {
      var ev = target;
      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
    } else if (!!target.getBoundingClientRect) {
      targetRectangle = _getRectangleFromElement(target);
    } else {
      var rectOrPoint = target;
      var left = rectOrPoint.left || rectOrPoint.x;
      var top_1 = rectOrPoint.top || rectOrPoint.y;
      var right = rectOrPoint.right || left;
      var bottom = rectOrPoint.bottom || top_1;
      targetRectangle = new Rectangle(left, right, top_1, bottom);
    }
    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
        var direction = outOfBounds_1[_i];
        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
      }
    }
  } else {
    targetRectangle = new Rectangle(0, 0, 0, 0);
  }
  return targetRectangle;
}
function _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {
  var maxHeight = 0;
  var directionalHint = DirectionalDictionary[targetEdge];
  var target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;
  if (target === RectangleEdge.top) {
    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;
  } else if (target === RectangleEdge.bottom) {
    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;
  } else {
    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;
  }
  return maxHeight > 0 ? maxHeight : bounds.height;
}
function _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {
  var gap = props.gapSpace ? props.gapSpace : 0;
  var targetRect = _getTargetRect(boundingRect, props.target);
  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);
  return __assign(__assign({}, positionedElement), { targetRectangle: targetRect });
}
function _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {
  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);
  return {
    elementPosition: finalizedElement,
    targetEdge: positionedElement.targetEdge,
    alignmentEdge: positionedElement.alignmentEdge
  };
}
function _positionElement(props, hostElement, elementToPosition, previousPositions) {
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var positionedElement = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);
  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);
}
function _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {
  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
  var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
  var positionProps = props;
  positionProps.gapSpace = gap;
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);
  var beakPositioned = _positionBeak(beakWidth, positionedElement);
  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);
  return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });
}
function _positionCard(props, hostElement, callout, previousPositions) {
  return _positionCallout(props, hostElement, callout, previousPositions, true);
}
function positionElement(props, hostElement, elementToPosition, previousPositions) {
  return _positionElement(props, hostElement, elementToPosition, previousPositions);
}
function positionCallout(props, hostElement, elementToPosition, previousPositions) {
  return _positionCallout(props, hostElement, elementToPosition, previousPositions);
}
function positionCard(props, hostElement, elementToPosition, previousPositions) {
  return _positionCard(props, hostElement, elementToPosition, previousPositions);
}
function getMaxHeight(target, targetEdge, gapSpace, bounds, coverTarget) {
  if (gapSpace === void 0) {
    gapSpace = 0;
  }
  var mouseTarget = target;
  var elementTarget = target;
  var rectOrPointTarget = target;
  var targetRect;
  var boundingRectangle = bounds ? _getRectangleFromIRect(bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var left = rectOrPointTarget.left || rectOrPointTarget.x;
  var top = rectOrPointTarget.top || rectOrPointTarget.y;
  var right = rectOrPointTarget.right || left;
  var bottom = rectOrPointTarget.bottom || top;
  if (!!mouseTarget.stopPropagation) {
    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);
  } else if (left !== void 0 && top !== void 0) {
    targetRect = new Rectangle(left, right, top, bottom);
  } else {
    targetRect = _getRectangleFromElement(elementTarget);
  }
  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);
}
function getOppositeEdge(edge) {
  return edge * -1;
}
function _getBoundsFromTargetWindow(target, targetWindow) {
  var segments = void 0;
  if (targetWindow.getWindowSegments) {
    segments = targetWindow.getWindowSegments();
  }
  if (segments === void 0 || segments.length <= 1) {
    return {
      top: 0,
      left: 0,
      right: targetWindow.innerWidth,
      bottom: targetWindow.innerHeight,
      width: targetWindow.innerWidth,
      height: targetWindow.innerHeight
    };
  }
  var x = 0;
  var y = 0;
  if (target !== null && !!target.getBoundingClientRect) {
    var clientRect = target.getBoundingClientRect();
    x = (clientRect.left + clientRect.right) / 2;
    y = (clientRect.top + clientRect.bottom) / 2;
  } else if (target !== null) {
    x = target.left || target.x;
    y = target.top || target.y;
  }
  var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };
  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {
      bounds = {
        top: segment.top,
        left: segment.left,
        right: segment.right,
        bottom: segment.bottom,
        width: segment.width,
        height: segment.height
      };
    }
  }
  return bounds;
}
function getBoundsFromTargetWindow(target, targetWindow) {
  return _getBoundsFromTargetWindow(target, targetWindow);
}

// node_modules/@fluentui/react/lib/components/Popup/Popup.js
var React20 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/version.js
setVersion("@fluentui/react-hooks", "8.6.20");

// node_modules/@fluentui/react-hooks/lib/useAsync.js
var React = __toESM(require_react());
function useAsync() {
  var asyncRef = React.useRef();
  if (!asyncRef.current) {
    asyncRef.current = new Async();
  }
  React.useEffect(function() {
    return function() {
      var _a4;
      (_a4 = asyncRef.current) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      asyncRef.current = void 0;
    };
  }, []);
  return asyncRef.current;
}

// node_modules/@fluentui/react-hooks/lib/useBoolean.js
var React3 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useConst.js
var React2 = __toESM(require_react());
function useConst(initialValue) {
  var ref = React2.useRef();
  if (ref.current === void 0) {
    ref.current = {
      value: typeof initialValue === "function" ? initialValue() : initialValue
    };
  }
  return ref.current.value;
}

// node_modules/@fluentui/react-hooks/lib/useBoolean.js
function useBoolean(initialState) {
  var _a4 = React3.useState(initialState), value = _a4[0], setValue = _a4[1];
  var setTrue = useConst(function() {
    return function() {
      setValue(true);
    };
  });
  var setFalse = useConst(function() {
    return function() {
      setValue(false);
    };
  });
  var toggle = useConst(function() {
    return function() {
      setValue(function(currentValue) {
        return !currentValue;
      });
    };
  });
  return [value, { setTrue, setFalse, toggle }];
}

// node_modules/@fluentui/react-hooks/lib/useConstCallback.js
var React4 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useControllableValue.js
var React5 = __toESM(require_react());
function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {
  var _a4 = React5.useState(defaultUncontrolledValue), value = _a4[0], setValue = _a4[1];
  var isControlled = useConst(controlledValue !== void 0);
  var currentValue = isControlled ? controlledValue : value;
  var valueRef = React5.useRef(currentValue);
  var onChangeRef = React5.useRef(onChange);
  React5.useEffect(function() {
    valueRef.current = currentValue;
    onChangeRef.current = onChange;
  });
  var setValueOrCallOnChange = useConst(function() {
    return function(update, ev) {
      var newValue = typeof update === "function" ? update(valueRef.current) : update;
      if (onChangeRef.current) {
        onChangeRef.current(ev, newValue);
      }
      if (!isControlled) {
        setValue(newValue);
      }
    };
  });
  return [currentValue, setValueOrCallOnChange];
}

// node_modules/@fluentui/react-hooks/lib/useEventCallback.js
var React6 = __toESM(require_react());
function useEventCallback(fn) {
  var callbackRef = React6.useRef(function() {
    throw new Error("Cannot call an event handler while rendering");
  });
  useIsomorphicLayoutEffect(function() {
    callbackRef.current = fn;
  }, [fn]);
  return useConst(function() {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var callback = callbackRef.current;
      return callback.apply(void 0, args);
    };
  });
}

// node_modules/@fluentui/react-hooks/lib/useForceUpdate.js
var React7 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useId.js
var React8 = __toESM(require_react());
function useId(prefix, providedId) {
  var ref = React8.useRef(providedId);
  if (!ref.current) {
    ref.current = getId(prefix);
  }
  return ref.current;
}

// node_modules/@fluentui/react-hooks/lib/useMergedRefs.js
var React9 = __toESM(require_react());
function useMergedRefs() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  var mergedCallback = React9.useCallback(function(value) {
    mergedCallback.current = value;
    for (var _i2 = 0, refs_1 = refs; _i2 < refs_1.length; _i2++) {
      var ref = refs_1[_i2];
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
  }, __spreadArray([], refs));
  return mergedCallback;
}

// node_modules/@fluentui/react-hooks/lib/useMount.js
var React10 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useMountSync.js
var React11 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useOnEvent.js
var React12 = __toESM(require_react());
function useOnEvent(element, eventName, callback, useCapture) {
  var callbackRef = React12.useRef(callback);
  callbackRef.current = callback;
  React12.useEffect(function() {
    var actualElement = element && "current" in element ? element.current : element;
    if (!actualElement) {
      return;
    }
    var dispose = on(actualElement, eventName, function(ev) {
      return callbackRef.current(ev);
    }, useCapture);
    return dispose;
  }, [element, eventName, useCapture]);
}

// node_modules/@fluentui/react-hooks/lib/usePrevious.js
var import_react = __toESM(require_react());
function usePrevious(value) {
  var ref = (0, import_react.useRef)();
  (0, import_react.useEffect)(function() {
    ref.current = value;
  });
  return ref.current;
}

// node_modules/@fluentui/react-hooks/lib/useRefEffect.js
var React13 = __toESM(require_react());
function useRefEffect(callback, initial) {
  if (initial === void 0) {
    initial = null;
  }
  var createRefCallback = function() {
    var refCallback = function(value) {
      if (data.ref.current !== value) {
        if (data.cleanup) {
          data.cleanup();
          data.cleanup = void 0;
        }
        data.ref.current = value;
        if (value !== null) {
          data.cleanup = data.callback(value);
        }
      }
    };
    refCallback.current = initial;
    return refCallback;
  };
  var data = React13.useRef({
    ref: createRefCallback(),
    callback
  }).current;
  data.callback = callback;
  return data.ref;
}

// node_modules/@fluentui/react-hooks/lib/useSetInterval.js
var React14 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useSetTimeout.js
var React15 = __toESM(require_react());
var useSetTimeout = function() {
  var timeoutIds = useConst({});
  React15.useEffect(
    function() {
      return function() {
        for (var _i = 0, _a4 = Object.keys(timeoutIds); _i < _a4.length; _i++) {
          var id = _a4[_i];
          clearTimeout(id);
        }
      };
    },
    // useConst ensures this will never change, but react-hooks/exhaustive-deps doesn't know that
    [timeoutIds]
  );
  return useConst({
    setTimeout: function(func, duration) {
      var id = setTimeout(func, duration);
      timeoutIds[id] = 1;
      return id;
    },
    clearTimeout: function(id) {
      delete timeoutIds[id];
      clearTimeout(id);
    }
  });
};

// node_modules/@fluentui/react-hooks/lib/useTarget.js
var React17 = __toESM(require_react());

// node_modules/@fluentui/react-window-provider/lib/WindowProvider.js
var React16 = __toESM(require_react());
var WindowContext = React16.createContext({
  window: typeof window === "object" ? window : void 0
});
var useWindow = function() {
  return React16.useContext(WindowContext).window;
};
var useDocument = function() {
  var _a4;
  return (_a4 = React16.useContext(WindowContext).window) === null || _a4 === void 0 ? void 0 : _a4.document;
};
var WindowProvider = function(props) {
  return React16.createElement(WindowContext.Provider, { value: props }, props.children);
};

// node_modules/@fluentui/react-window-provider/lib/version.js
setVersion("@fluentui/react-window-provider", "2.2.9");

// node_modules/@fluentui/react-hooks/lib/useTarget.js
function useTarget(target, hostElement) {
  var previousTargetProp = React17.useRef();
  var targetRef = React17.useRef(null);
  var targetWindow = useWindow();
  if (!target || target !== previousTargetProp.current || typeof target === "string") {
    var currentElement = hostElement === null || hostElement === void 0 ? void 0 : hostElement.current;
    if (target) {
      if (typeof target === "string") {
        var currentDoc = getDocument(currentElement);
        targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;
      } else if ("stopPropagation" in target) {
        targetRef.current = target;
      } else if ("getBoundingClientRect" in target) {
        targetRef.current = target;
      } else if ("current" in target) {
        targetRef.current = target.current;
      } else {
        targetRef.current = target;
      }
    }
    previousTargetProp.current = target;
  }
  return [targetRef, targetWindow];
}

// node_modules/@fluentui/react-hooks/lib/useUnmount.js
var React18 = __toESM(require_react());
var useUnmount = function(callback) {
  var unmountRef = React18.useRef(callback);
  unmountRef.current = callback;
  React18.useEffect(function() {
    return function() {
      var _a4;
      (_a4 = unmountRef.current) === null || _a4 === void 0 ? void 0 : _a4.call(unmountRef);
    };
  }, []);
};

// node_modules/@fluentui/react-hooks/lib/useWarnings.js
var React19 = __toESM(require_react());
var warningId = 0;
function useWarnings(options) {
  if (true) {
    var name_1 = options.name, props = options.props, _a4 = options.other, other = _a4 === void 0 ? [] : _a4, conditionallyRequired = options.conditionallyRequired, deprecations = options.deprecations, mutuallyExclusive = options.mutuallyExclusive, controlledUsage = options.controlledUsage;
    var hasWarnedRef = React19.useRef(false);
    var componentId = useConst(function() {
      return "useWarnings_" + warningId++;
    });
    var oldProps = usePrevious(props);
    if (!hasWarnedRef.current) {
      hasWarnedRef.current = true;
      for (var _i = 0, other_1 = other; _i < other_1.length; _i++) {
        var warning = other_1[_i];
        warn(warning);
      }
      if (conditionallyRequired) {
        for (var _b = 0, conditionallyRequired_1 = conditionallyRequired; _b < conditionallyRequired_1.length; _b++) {
          var req = conditionallyRequired_1[_b];
          warnConditionallyRequiredProps(name_1, props, req.requiredProps, req.conditionalPropName, req.condition);
        }
      }
      deprecations && warnDeprecations(name_1, props, deprecations);
      mutuallyExclusive && warnMutuallyExclusive(name_1, props, mutuallyExclusive);
    }
    controlledUsage && warnControlledUsage(__assign(__assign({}, controlledUsage), { componentId, props, componentName: name_1, oldProps }));
  }
}

// node_modules/@fluentui/react/lib/components/Popup/Popup.js
function useScrollbarAsync(props, root) {
  var async = useAsync();
  var _a4 = React20.useState(false), needsVerticalScrollBarState = _a4[0], setNeedsVerticalScrollBar = _a4[1];
  React20.useEffect(function() {
    async.requestAnimationFrame(function() {
      var _a5;
      if (props.style && props.style.overflowY) {
        return;
      }
      var needsVerticalScrollBar = false;
      if (root && root.current && ((_a5 = root.current) === null || _a5 === void 0 ? void 0 : _a5.firstElementChild)) {
        var rootHeight = root.current.clientHeight;
        var firstChildHeight = root.current.firstElementChild.clientHeight;
        if (rootHeight > 0 && firstChildHeight > rootHeight) {
          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
        }
      }
      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {
        setNeedsVerticalScrollBar(needsVerticalScrollBar);
      }
    });
    return function() {
      return async.dispose();
    };
  });
  return needsVerticalScrollBarState;
}
function defaultFocusRestorer(options) {
  var originalElement = options.originalElement, containsFocus = options.containsFocus;
  if (originalElement && containsFocus && originalElement !== getWindow()) {
    setTimeout(function() {
      var _a4;
      (_a4 = originalElement.focus) === null || _a4 === void 0 ? void 0 : _a4.call(originalElement);
    }, 0);
  }
}
function useRestoreFocus(props, root) {
  var _a4 = props.onRestoreFocus, onRestoreFocus = _a4 === void 0 ? defaultFocusRestorer : _a4;
  var originalFocusedElement = React20.useRef();
  var containsFocus = React20.useRef(false);
  React20.useEffect(function() {
    originalFocusedElement.current = getDocument().activeElement;
    if (doesElementContainFocus(root.current)) {
      containsFocus.current = true;
    }
    return function() {
      var _a5;
      onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({
        originalElement: originalFocusedElement.current,
        containsFocus: containsFocus.current,
        documentContainsFocus: ((_a5 = getDocument()) === null || _a5 === void 0 ? void 0 : _a5.hasFocus()) || false
      });
      originalFocusedElement.current = void 0;
    };
  }, []);
  useOnEvent(root, "focus", React20.useCallback(function() {
    containsFocus.current = true;
  }, []), true);
  useOnEvent(root, "blur", React20.useCallback(function(ev) {
    if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget)) {
      containsFocus.current = false;
    }
  }, []), true);
}
function useHideSiblingNodes(props, root) {
  var shouldHideSiblings = String(props["aria-modal"]).toLowerCase() === "true" && props.enableAriaHiddenSiblings;
  React20.useEffect(function() {
    if (!(shouldHideSiblings && root.current)) {
      return;
    }
    var unmodalize = modalize(root.current);
    return unmodalize;
  }, [root, shouldHideSiblings]);
}
var Popup = React20.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults({ shouldRestoreFocus: true, enableAriaHiddenSiblings: true }, propsWithoutDefaults);
  var root = React20.useRef();
  var mergedRootRef = useMergedRefs(root, forwardedRef);
  useHideSiblingNodes(props, root);
  useRestoreFocus(props, root);
  var role = props.role, className = props.className, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, style = props.style, children = props.children, onDismiss = props.onDismiss;
  var needsVerticalScrollBar = useScrollbarAsync(props, root);
  var onKeyDown = React20.useCallback(function(ev) {
    switch (ev.which) {
      case KeyCodes.escape:
        if (onDismiss) {
          onDismiss(ev);
          ev.preventDefault();
          ev.stopPropagation();
        }
        break;
    }
  }, [onDismiss]);
  var win = useWindow();
  useOnEvent(win, "keydown", onKeyDown);
  return React20.createElement("div", __assign({ ref: mergedRootRef }, getNativeProps(props, divProperties), { className, role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown, style: __assign({ overflowY: needsVerticalScrollBar ? "scroll" : void 0, outline: "none" }, style) }), children);
});
Popup.displayName = "Popup";

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.base.js
var _a2;
var COMPONENT_NAME = "CalloutContentBase";
var ANIMATIONS = (_a2 = {}, _a2[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a2[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a2[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a2[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a2);
var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
var OFF_SCREEN_STYLE = {
  opacity: 0,
  filter: "opacity(0)",
  pointerEvents: "none"
};
var ARIA_ROLE_ATTRIBUTES = ["role", "aria-roledescription"];
var DEFAULT_PROPS = {
  preventDismissOnLostFocus: false,
  preventDismissOnScroll: false,
  preventDismissOnResize: false,
  isBeakVisible: true,
  beakWidth: 16,
  gapSpace: 0,
  minPagePadding: 8,
  directionalHint: DirectionalHint.bottomAutoEdge
};
var getClassNames = classNamesFunction({
  disableCaching: true
  // disabling caching because stylesProp.position mutates often
});
function useBounds(_a4, targetRef, targetWindow) {
  var bounds = _a4.bounds, _b = _a4.minPagePadding, minPagePadding = _b === void 0 ? DEFAULT_PROPS.minPagePadding : _b, target = _a4.target;
  var _c = React21.useState(false), targetWindowResized = _c[0], setTargetWindowResized = _c[1];
  var cachedBounds = React21.useRef();
  var getBounds = React21.useCallback(function() {
    if (!cachedBounds.current || targetWindowResized) {
      var currentBounds = typeof bounds === "function" ? targetWindow ? bounds(target, targetWindow) : void 0 : bounds;
      if (!currentBounds && targetWindow) {
        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);
        currentBounds = {
          top: currentBounds.top + minPagePadding,
          left: currentBounds.left + minPagePadding,
          right: currentBounds.right - minPagePadding,
          bottom: currentBounds.bottom - minPagePadding,
          width: currentBounds.width - minPagePadding * 2,
          height: currentBounds.height - minPagePadding * 2
        };
      }
      cachedBounds.current = currentBounds;
      targetWindowResized && setTargetWindowResized(false);
    }
    return cachedBounds.current;
  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);
  var async = useAsync();
  useOnEvent(targetWindow, "resize", async.debounce(function() {
    setTargetWindowResized(true);
  }, 500, { leading: true }));
  return getBounds;
}
function useMaxHeight(_a4, getBounds, positions) {
  var _b;
  var calloutMaxHeight = _a4.calloutMaxHeight, finalHeight = _a4.finalHeight, directionalHint = _a4.directionalHint, directionalHintFixed = _a4.directionalHintFixed, hidden = _a4.hidden;
  var _c = React21.useState(), maxHeight = _c[0], setMaxHeight = _c[1];
  var _d = (_b = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b !== void 0 ? _b : {}, top = _d.top, bottom = _d.bottom;
  React21.useEffect(function() {
    var _a5;
    var _b2 = (_a5 = getBounds()) !== null && _a5 !== void 0 ? _a5 : {}, topBounds = _b2.top, bottomBounds = _b2.bottom;
    if (!calloutMaxHeight && !hidden) {
      if (typeof top === "number" && bottomBounds) {
        setMaxHeight(bottomBounds - top);
      } else if (typeof bottom === "number" && typeof topBounds === "number" && bottomBounds) {
        setMaxHeight(bottomBounds - topBounds - bottom);
      }
    } else if (calloutMaxHeight) {
      setMaxHeight(calloutMaxHeight);
    } else {
      setMaxHeight(void 0);
    }
  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);
  return maxHeight;
}
function usePositions(props, hostElement, calloutElement, targetRef, getBounds) {
  var _a4 = React21.useState(), positions = _a4[0], setPositions = _a4[1];
  var positionAttempts = React21.useRef(0);
  var previousTarget = React21.useRef();
  var async = useAsync();
  var hidden = props.hidden, target = props.target, finalHeight = props.finalHeight, calloutMaxHeight = props.calloutMaxHeight, onPositioned = props.onPositioned, directionalHint = props.directionalHint;
  React21.useEffect(function() {
    if (!hidden) {
      var timerId_1 = async.requestAnimationFrame(function() {
        var _a5, _b;
        if (hostElement.current && calloutElement) {
          var currentProps = __assign(__assign({}, props), { target: targetRef.current, bounds: getBounds() });
          var dupeCalloutElement = calloutElement.cloneNode(true);
          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? "" + calloutMaxHeight : "";
          dupeCalloutElement.style.visibility = "hidden";
          (_a5 = calloutElement.parentElement) === null || _a5 === void 0 ? void 0 : _a5.appendChild(dupeCalloutElement);
          var previousPositions = previousTarget.current === target ? positions : void 0;
          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);
          (_b = calloutElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(dupeCalloutElement);
          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {
            positionAttempts.current++;
            setPositions(newPositions);
          } else if (positionAttempts.current > 0) {
            positionAttempts.current = 0;
            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);
          }
        }
      }, calloutElement);
      previousTarget.current = target;
      return function() {
        async.cancelAnimationFrame(timerId_1);
        previousTarget.current = void 0;
      };
    } else {
      setPositions(void 0);
      positionAttempts.current = 0;
    }
  }, [
    hidden,
    directionalHint,
    async,
    calloutElement,
    calloutMaxHeight,
    hostElement,
    targetRef,
    finalHeight,
    getBounds,
    onPositioned,
    positions,
    props,
    target
  ]);
  return positions;
}
function useAutoFocus(_a4, positions, calloutElement) {
  var hidden = _a4.hidden, setInitialFocus = _a4.setInitialFocus;
  var async = useAsync();
  var hasPositions = !!positions;
  React21.useEffect(function() {
    if (!hidden && setInitialFocus && hasPositions && calloutElement) {
      var timerId_2 = async.requestAnimationFrame(function() {
        return focusFirstChild(calloutElement);
      }, calloutElement);
      return function() {
        return async.cancelAnimationFrame(timerId_2);
      };
    }
  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
}
function useDismissHandlers(_a4, positions, hostElement, targetRef, targetWindow) {
  var hidden = _a4.hidden, onDismiss = _a4.onDismiss, preventDismissOnScroll = _a4.preventDismissOnScroll, preventDismissOnResize = _a4.preventDismissOnResize, preventDismissOnLostFocus = _a4.preventDismissOnLostFocus, dismissOnTargetClick = _a4.dismissOnTargetClick, shouldDismissOnWindowFocus = _a4.shouldDismissOnWindowFocus, preventDismissOnEvent = _a4.preventDismissOnEvent;
  var isMouseDownOnPopup = React21.useRef(false);
  var async = useAsync();
  var mouseDownHandlers = useConst([
    function() {
      isMouseDownOnPopup.current = true;
    },
    function() {
      isMouseDownOnPopup.current = false;
    }
  ]);
  var positionsExists = !!positions;
  React21.useEffect(function() {
    var dismissOnScroll = function(ev) {
      if (positionsExists && !preventDismissOnScroll) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnResize = function(ev) {
      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnLostFocus = function(ev) {
      if (!preventDismissOnLostFocus) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnClickOrScroll = function(ev) {
      var eventPaths = ev.composedPath ? ev.composedPath() : [];
      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;
      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);
      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {
        isMouseDownOnPopup.current = false;
        return;
      }
      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || "stopPropagation" in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {
        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {
          return;
        }
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnTargetWindowBlur = function(ev) {
      if (!shouldDismissOnWindowFocus) {
        return;
      }
      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var disposablesPromise = new Promise(function(resolve) {
      async.setTimeout(function() {
        if (!hidden && targetWindow) {
          var disposables_1 = [
            on(targetWindow, "scroll", dismissOnScroll, true),
            on(targetWindow, "resize", dismissOnResize, true),
            on(targetWindow.document.documentElement, "focus", dismissOnLostFocus, true),
            on(targetWindow.document.documentElement, "click", dismissOnLostFocus, true),
            on(targetWindow, "blur", dismissOnTargetWindowBlur, true)
          ];
          resolve(function() {
            disposables_1.forEach(function(dispose) {
              return dispose();
            });
          });
        }
      }, 0);
    });
    return function() {
      disposablesPromise.then(function(dispose) {
        return dispose();
      });
    };
  }, [
    hidden,
    async,
    hostElement,
    targetRef,
    targetWindow,
    onDismiss,
    shouldDismissOnWindowFocus,
    dismissOnTargetClick,
    preventDismissOnLostFocus,
    preventDismissOnResize,
    preventDismissOnScroll,
    positionsExists,
    preventDismissOnEvent
  ]);
  return mouseDownHandlers;
}
var CalloutContentBase = React21.memo(React21.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
  var styles = props.styles, style = props.style, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, ariaLabelledBy = props.ariaLabelledBy, className = props.className, isBeakVisible = props.isBeakVisible, children = props.children, beakWidth = props.beakWidth, calloutWidth = props.calloutWidth, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer, finalHeight = props.finalHeight, _a4 = props.hideOverflow, hideOverflow = _a4 === void 0 ? !!finalHeight : _a4, backgroundColor2 = props.backgroundColor, calloutMaxHeight = props.calloutMaxHeight, onScroll = props.onScroll, _b = props.shouldRestoreFocus, shouldRestoreFocus = _b === void 0 ? true : _b, target = props.target, hidden = props.hidden, onLayerMounted = props.onLayerMounted, popupProps = props.popupProps;
  var hostElement = React21.useRef(null);
  var _c = React21.useState(null), calloutElement = _c[0], setCalloutElement = _c[1];
  var calloutCallback = React21.useCallback(function(calloutEl) {
    setCalloutElement(calloutEl);
  }, []);
  var rootRef = useMergedRefs(hostElement, forwardedRef);
  var _d = useTarget(props.target, {
    current: calloutElement
  }), targetRef = _d[0], targetWindow = _d[1];
  var getBounds = useBounds(props, targetRef, targetWindow);
  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);
  var maxHeight = useMaxHeight(props, getBounds, positions);
  var _e = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow), mouseDownOnPopup = _e[0], mouseUpOnPopup = _e[1];
  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);
  var cssPositions = __assign(__assign({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), { maxHeight });
  if (isForcedInBounds) {
    cssPositions.bottom = void 0;
  }
  useAutoFocus(props, positions, calloutElement);
  React21.useEffect(function() {
    if (!hidden) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
    }
  }, [hidden]);
  if (!targetWindow) {
    return null;
  }
  var overflowYHidden = hideOverflow;
  var beakVisible = isBeakVisible && !!target;
  var classNames2 = getClassNames(styles, {
    theme: props.theme,
    className,
    overflowYHidden,
    calloutWidth,
    positions,
    beakWidth,
    backgroundColor: backgroundColor2,
    calloutMaxWidth,
    calloutMinWidth,
    doNotLayer
  });
  var overflowStyle = __assign(__assign({ maxHeight: calloutMaxHeight ? calloutMaxHeight : "100%" }, style), overflowYHidden && { overflowY: "hidden" });
  var visibilityStyle = props.hidden ? { visibility: "hidden" } : void 0;
  return React21.createElement(
    "div",
    { ref: rootRef, className: classNames2.container, style: visibilityStyle },
    React21.createElement(
      "div",
      __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {
        className: css(classNames2.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),
        style: positions ? __assign({}, cssPositions) : OFF_SCREEN_STYLE,
        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.
        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        tabIndex: -1,
        ref: calloutCallback
      }),
      beakVisible && React21.createElement("div", { className: classNames2.beak, style: getBeakPosition(positions) }),
      beakVisible && React21.createElement("div", { className: classNames2.beakCurtain }),
      React21.createElement(
        Popup,
        __assign({
          // don't use getNativeElementProps for role and roledescription because it will also
          // pass through data-* props (resulting in them being used in two places)
          role: props.role,
          "aria-roledescription": props["aria-roledescription"],
          ariaDescribedBy,
          ariaLabel,
          ariaLabelledBy,
          className: classNames2.calloutMain,
          onDismiss: props.onDismiss,
          onMouseDown: mouseDownOnPopup,
          onMouseUp: mouseUpOnPopup,
          onRestoreFocus: props.onRestoreFocus,
          onScroll,
          shouldRestoreFocus,
          style: overflowStyle
        }, popupProps),
        children
      )
    )
  );
}), function(previousProps, nextProps) {
  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {
    return true;
  }
  return shallowCompare(previousProps, nextProps);
});
function getBeakPosition(positions) {
  var _a4, _b;
  var beakPositionStyle = __assign(__assign({}, (_a4 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a4 === void 0 ? void 0 : _a4.elementPosition), { display: ((_b = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b === void 0 ? void 0 : _b.hideBeak) ? "none" : void 0 });
  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {
    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;
    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;
  }
  return beakPositionStyle;
}
function arePositionsEqual(prevElementPositions, newElementPosition) {
  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);
}
function comparePositions(prevElementPositions, newElementPositions) {
  for (var key in newElementPositions) {
    if (newElementPositions.hasOwnProperty(key)) {
      var oldPositionEdge = prevElementPositions[key];
      var newPositionEdge = newElementPositions[key];
      if (oldPositionEdge !== void 0 && newPositionEdge !== void 0) {
        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}
CalloutContentBase.displayName = COMPONENT_NAME;

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.styles.js
function getBeakStyle(beakWidth) {
  return {
    height: beakWidth,
    width: beakWidth
  };
}
var GlobalClassNames = {
  container: "ms-Callout-container",
  root: "ms-Callout",
  beak: "ms-Callout-beak",
  beakCurtain: "ms-Callout-beakCurtain",
  calloutMain: "ms-Callout-main"
};
var getStyles = function(props) {
  var _a4;
  var theme = props.theme, className = props.className, overflowYHidden = props.overflowYHidden, calloutWidth = props.calloutWidth, beakWidth = props.beakWidth, backgroundColor2 = props.backgroundColor, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer;
  var classNames2 = getGlobalClassNames(GlobalClassNames, theme);
  var semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    container: [
      classNames2.container,
      {
        position: "relative"
      }
    ],
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        position: "absolute",
        display: "flex",
        zIndex: doNotLayer ? ZIndexes.Layer : void 0,
        boxSizing: "border-box",
        borderRadius: effects.roundedCorner2,
        boxShadow: effects.elevation16,
        selectors: (_a4 = {}, _a4[HighContrastSelector] = {
          borderWidth: 1,
          borderStyle: "solid",
          borderColor: "WindowText"
        }, _a4)
      },
      focusClear(),
      className,
      !!calloutWidth && { width: calloutWidth },
      !!calloutMaxWidth && { maxWidth: calloutMaxWidth },
      !!calloutMinWidth && { minWidth: calloutMinWidth }
    ],
    beak: [
      classNames2.beak,
      {
        position: "absolute",
        backgroundColor: semanticColors.menuBackground,
        boxShadow: "inherit",
        border: "inherit",
        boxSizing: "border-box",
        transform: "rotate(45deg)"
      },
      getBeakStyle(beakWidth),
      backgroundColor2 && {
        backgroundColor: backgroundColor2
      }
    ],
    beakCurtain: [
      classNames2.beakCurtain,
      {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        backgroundColor: semanticColors.menuBackground,
        borderRadius: effects.roundedCorner2
      }
    ],
    calloutMain: [
      classNames2.calloutMain,
      {
        backgroundColor: semanticColors.menuBackground,
        overflowX: "hidden",
        overflowY: "auto",
        position: "relative",
        width: "100%",
        borderRadius: effects.roundedCorner2
      },
      overflowYHidden && {
        overflowY: "hidden"
      },
      backgroundColor2 && {
        backgroundColor: backgroundColor2
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.js
var CalloutContent = styled(CalloutContentBase, getStyles, void 0, {
  scope: "CalloutContent"
});

// node_modules/@fluentui/react-portal-compat-context/lib/PortalCompatContext.js
var React22 = __toESM(require_react());
var PortalCompatContext = React22.createContext(void 0);
var portalCompatContextDefaultValue = () => () => void 0;
var PortalCompatContextProvider = PortalCompatContext.Provider;
function usePortalCompat() {
  var _React_useContext;
  return (_React_useContext = React22.useContext(PortalCompatContext)) !== null && _React_useContext !== void 0 ? _React_useContext : portalCompatContextDefaultValue;
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.base.js
var React24 = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.base.js
var React23 = __toESM(require_react());
var getClassNames2 = classNamesFunction();
var getFabricTheme = memoizeFunction(function(theme, isRTL) {
  return createTheme(__assign(__assign({}, theme), { rtl: isRTL }));
});
var getDir = function(_a4) {
  var theme = _a4.theme, dir = _a4.dir;
  var contextDir = getRTL(theme) ? "rtl" : "ltr";
  var pageDir = getRTL() ? "rtl" : "ltr";
  var componentDir = dir ? dir : contextDir;
  return {
    // If Fabric dir !== contextDir
    // Or If contextDir !== pageDir
    // Then we need to set dir of the Fabric root
    rootDir: componentDir !== contextDir || componentDir !== pageDir ? componentDir : dir,
    // If dir !== contextDir || pageDir
    // then set contextual theme around content
    needsTheme: componentDir !== contextDir
  };
};
var FabricBase = React23.forwardRef(function(props, ref) {
  var className = props.className, theme = props.theme, applyTheme = props.applyTheme, applyThemeToBody = props.applyThemeToBody, styles = props.styles;
  var classNames2 = getClassNames2(styles, {
    theme,
    applyTheme,
    className
  });
  var rootElement = React23.useRef(null);
  useApplyThemeToBody(applyThemeToBody, classNames2, rootElement);
  return React23.createElement(React23.Fragment, null, useRenderedContent(props, classNames2, rootElement, ref));
});
FabricBase.displayName = "FabricBase";
function useRenderedContent(props, _a4, rootElement, ref) {
  var root = _a4.root;
  var _b = props.as, Root = _b === void 0 ? "div" : _b, dir = props.dir, theme = props.theme;
  var divProps = getNativeProps(props, divProperties, ["dir"]);
  var _c = getDir(props), rootDir = _c.rootDir, needsTheme = _c.needsTheme;
  var renderedContent = React23.createElement(
    FocusRectsProvider,
    { providerRef: rootElement },
    React23.createElement(Root, __assign({ dir: rootDir }, divProps, { className: root, ref: useMergedRefs(rootElement, ref) }))
  );
  if (needsTheme) {
    renderedContent = // eslint-disable-next-line deprecation/deprecation
    React23.createElement(Customizer, { settings: { theme: getFabricTheme(theme, dir === "rtl") } }, renderedContent);
  }
  return renderedContent;
}
function useApplyThemeToBody(applyThemeToBody, _a4, rootElement) {
  var bodyThemed = _a4.bodyThemed;
  React23.useEffect(function() {
    if (applyThemeToBody) {
      var currentDoc_1 = getDocument(rootElement.current);
      if (currentDoc_1) {
        currentDoc_1.body.classList.add(bodyThemed);
        return function() {
          currentDoc_1.body.classList.remove(bodyThemed);
        };
      }
    }
  }, [bodyThemed, applyThemeToBody, rootElement]);
  return rootElement;
}

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.styles.js
var inheritFont = { fontFamily: "inherit" };
var GlobalClassNames2 = {
  root: "ms-Fabric",
  bodyThemed: "ms-Fabric-bodyThemed"
};
var getStyles2 = function(props) {
  var applyTheme = props.applyTheme, className = props.className, preventBlanketFontInheritance = props.preventBlanketFontInheritance, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames2, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        color: theme.palette.neutralPrimary
      },
      !preventBlanketFontInheritance && {
        "& button": inheritFont,
        "& input": inheritFont,
        "& textarea": inheritFont
      },
      // apply theme to only if applyTheme is true
      applyTheme && {
        color: theme.semanticColors.bodyText,
        backgroundColor: theme.semanticColors.bodyBackground
      },
      className
    ],
    bodyThemed: [
      {
        backgroundColor: theme.semanticColors.bodyBackground
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.js
var Fabric = styled(FabricBase, getStyles2, void 0, {
  scope: "Fabric"
});

// node_modules/@fluentui/react/lib/components/Layer/Layer.notification.js
var _layersByHostId = {};
var _layerHostsById = {};
var defaultHostId = "fluent-default-layer-host";
var _defaultHostSelector = "#" + defaultHostId;
function registerLayer(hostId, callback) {
  if (!_layersByHostId[hostId]) {
    _layersByHostId[hostId] = [];
  }
  _layersByHostId[hostId].push(callback);
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_1 = layerHosts; _i < layerHosts_1.length; _i++) {
      var layerHost = layerHosts_1[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function unregisterLayer(hostId, callback) {
  var layers = _layersByHostId[hostId];
  if (layers) {
    var idx = layers.indexOf(callback);
    if (idx >= 0) {
      layers.splice(idx, 1);
      if (layers.length === 0) {
        delete _layersByHostId[hostId];
      }
    }
  }
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_2 = layerHosts; _i < layerHosts_2.length; _i++) {
      var layerHost = layerHosts_2[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function getLayerCount(hostId) {
  var layers = _layerHostsById[hostId];
  return layers ? layers.length : 0;
}
function getLayerHost(hostId) {
  var layerHosts = _layerHostsById[hostId];
  return layerHosts && layerHosts[0] || void 0;
}
function registerLayerHost(hostId, layerHost) {
  var layerHosts = _layerHostsById[hostId] || (_layerHostsById[hostId] = []);
  layerHosts.unshift(layerHost);
}
function unregisterLayerHost(hostId, layerHost) {
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    var idx = layerHosts.indexOf(layerHost);
    if (idx >= 0) {
      layerHosts.splice(idx, 1);
    }
    if (layerHosts.length === 0) {
      delete _layerHostsById[hostId];
    }
  }
}
function createDefaultLayerHost(doc) {
  var host = doc.createElement("div");
  host.setAttribute("id", defaultHostId);
  host.style.cssText = "position:fixed;z-index:1000000";
  doc === null || doc === void 0 ? void 0 : doc.body.appendChild(host);
  return host;
}
function cleanupDefaultLayerHost(doc) {
  var host = doc.querySelector("#" + defaultHostId);
  if (host) {
    doc.removeChild(host);
  }
}
function notifyHostChanged(id) {
  if (_layersByHostId[id]) {
    _layersByHostId[id].forEach(function(callback) {
      return callback();
    });
  }
}
function setDefaultTarget(selector) {
  _defaultHostSelector = selector;
}
function getDefaultTarget() {
  return _defaultHostSelector;
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.base.js
var getClassNames3 = classNamesFunction();
var LayerBase = React24.forwardRef(function(props, ref) {
  var registerPortalEl = usePortalCompat();
  var rootRef = React24.useRef(null);
  var mergedRef = useMergedRefs(rootRef, ref);
  var layerRef = React24.useRef();
  var fabricElementRef = React24.useRef(null);
  var _a4 = React24.useState(false), needRaiseLayerMount = _a4[0], setNeedRaiseLayerMount = _a4[1];
  var children = props.children, className = props.className, eventBubblingEnabled = props.eventBubblingEnabled, fabricProps = props.fabricProps, hostId = props.hostId, insertFirst = props.insertFirst, _b = props.onLayerDidMount, onLayerDidMount = _b === void 0 ? function() {
    return void 0;
  } : _b, _c = props.onLayerMounted, onLayerMounted = _c === void 0 ? function() {
    return void 0;
  } : _c, onLayerWillUnmount = props.onLayerWillUnmount, styles = props.styles, theme = props.theme;
  var fabricRef = useMergedRefs(fabricElementRef, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.ref);
  var classNames2 = getClassNames3(styles, {
    theme,
    className,
    isNotHost: !hostId
  });
  var getHost = function(doc) {
    var _a5, _b2;
    if (hostId) {
      var layerHost = getLayerHost(hostId);
      if (layerHost) {
        return (_a5 = layerHost.rootRef.current) !== null && _a5 !== void 0 ? _a5 : null;
      }
      return (_b2 = doc.getElementById(hostId)) !== null && _b2 !== void 0 ? _b2 : null;
    } else {
      var defaultHostSelector = getDefaultTarget();
      var host = defaultHostSelector ? doc.querySelector(defaultHostSelector) : null;
      if (!host) {
        host = createDefaultLayerHost(doc);
      }
      return host;
    }
  };
  var removeLayerElement = function() {
    onLayerWillUnmount === null || onLayerWillUnmount === void 0 ? void 0 : onLayerWillUnmount();
    var elem = layerRef.current;
    layerRef.current = void 0;
    if (elem && elem.parentNode) {
      elem.parentNode.removeChild(elem);
    }
  };
  var createLayerElement = function() {
    var _a5;
    var doc = getDocument(rootRef.current);
    if (!doc) {
      return;
    }
    var host = getHost(doc);
    if (!host) {
      return;
    }
    removeLayerElement();
    var el = ((_a5 = host.ownerDocument) !== null && _a5 !== void 0 ? _a5 : doc).createElement("div");
    el.className = classNames2.root;
    setPortalAttribute(el);
    setVirtualParent(el, rootRef.current);
    insertFirst ? host.insertBefore(el, host.firstChild) : host.appendChild(el);
    layerRef.current = el;
    setNeedRaiseLayerMount(true);
  };
  useIsomorphicLayoutEffect(function() {
    createLayerElement();
    if (hostId) {
      registerLayer(hostId, createLayerElement);
    }
    var unregisterPortalEl = layerRef.current ? registerPortalEl(layerRef.current) : void 0;
    return function() {
      if (unregisterPortalEl) {
        unregisterPortalEl();
      }
      removeLayerElement();
      if (hostId) {
        unregisterLayer(hostId, createLayerElement);
      }
    };
  }, [hostId]);
  React24.useEffect(function() {
    if (layerRef.current && needRaiseLayerMount) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
      onLayerDidMount === null || onLayerDidMount === void 0 ? void 0 : onLayerDidMount();
      setNeedRaiseLayerMount(false);
    }
  }, [needRaiseLayerMount, onLayerMounted, onLayerDidMount]);
  useDebugWarnings(props);
  return React24.createElement("span", { className: "ms-layer", ref: mergedRef }, layerRef.current && ReactDOM.createPortal(React24.createElement(
    FocusRectsProvider,
    { layerRoot: true, providerRef: fabricRef },
    React24.createElement(Fabric, __assign({}, !eventBubblingEnabled && getFilteredEvents(), fabricProps, { className: css(classNames2.content, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.className), ref: fabricRef }), children)
  ), layerRef.current));
});
LayerBase.displayName = "LayerBase";
var filteredEventProps;
var onFilterEvent = function(ev) {
  if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== "mouseenter" && ev.type !== "mouseleave" && ev.type !== "touchstart" && ev.type !== "touchend") {
    ev.stopPropagation();
  }
};
function getFilteredEvents() {
  if (!filteredEventProps) {
    filteredEventProps = {};
    [
      "onClick",
      "onContextMenu",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOver",
      "onMouseOut",
      "onMouseUp",
      "onTouchMove",
      "onTouchStart",
      "onTouchCancel",
      "onTouchEnd",
      "onKeyDown",
      "onKeyPress",
      "onKeyUp",
      "onFocus",
      "onBlur",
      "onChange",
      "onInput",
      "onInvalid",
      "onSubmit"
    ].forEach(function(name) {
      return filteredEventProps[name] = onFilterEvent;
    });
  }
  return filteredEventProps;
}
function useDebugWarnings(props) {
  if (true) {
    useWarnings({
      name: "Layer",
      props,
      deprecations: { onLayerMounted: "onLayerDidMount" }
    });
  }
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.styles.js
var GlobalClassNames3 = {
  root: "ms-Layer",
  rootNoHost: "ms-Layer--fixed",
  content: "ms-Layer-content"
};
var getStyles3 = function(props) {
  var className = props.className, isNotHost = props.isNotHost, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames3, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      isNotHost && [
        classNames2.rootNoHost,
        {
          position: "fixed",
          zIndex: ZIndexes.Layer,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          visibility: "hidden"
        }
      ],
      className
    ],
    content: [
      classNames2.content,
      {
        visibility: "visible"
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Layer/Layer.js
var Layer = styled(LayerBase, getStyles3, void 0, {
  scope: "Layer",
  fields: ["hostId", "theme", "styles"]
});

// node_modules/@fluentui/react/lib/components/Layer/LayerHost.js
var React25 = __toESM(require_react());
var LayerHost = function(props) {
  var className = props.className;
  var layerHostId = React25.useState(function() {
    return getId();
  })[0];
  var _a4 = props.id, hostId = _a4 === void 0 ? layerHostId : _a4;
  var layerHostRef = React25.useRef({
    hostId,
    rootRef: React25.useRef(null),
    notifyLayersChanged: function() {
    }
  });
  React25.useImperativeHandle(props.componentRef, function() {
    return layerHostRef.current;
  });
  React25.useEffect(function() {
    registerLayerHost(hostId, layerHostRef.current);
    notifyHostChanged(hostId);
  }, []);
  useUnmount(function() {
    unregisterLayerHost(hostId, layerHostRef.current);
    notifyHostChanged(hostId);
  });
  return React25.createElement("div", __assign({}, props, { className: css("ms-LayerHost", className), ref: layerHostRef.current.rootRef }));
};

// node_modules/@fluentui/react/lib/components/Callout/Callout.js
var Callout = React26.forwardRef(function(_a4, forwardedRef) {
  var layerProps = _a4.layerProps, doNotLayer = _a4.doNotLayer, rest = __rest(_a4, ["layerProps", "doNotLayer"]);
  var content = React26.createElement(CalloutContent, __assign({}, rest, { doNotLayer, ref: forwardedRef }));
  return doNotLayer ? content : React26.createElement(Layer, __assign({}, layerProps), content);
});
Callout.displayName = "Callout";

// node_modules/@fluentui/react/lib/components/Callout/FocusTrapCallout.js
var React28 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/FocusTrapZone/FocusTrapZone.js
var React27 = __toESM(require_react());
var COMPONENT_NAME2 = "FocusTrapZone";
var DEFAULT_PROPS2 = {
  disabled: false,
  disableFirstFocus: false,
  forceFocusInsideTrap: true,
  isClickableOutsideFocusTrap: false
};
var useComponentRef = function(componentRef, previouslyFocusedElement, focusFTZ) {
  React27.useImperativeHandle(componentRef, function() {
    return {
      get previouslyFocusedElement() {
        return previouslyFocusedElement;
      },
      focus: focusFTZ
    };
  }, [focusFTZ, previouslyFocusedElement]);
};
var FocusTrapZone = React27.forwardRef(function(propsWithoutDefaults, ref) {
  var _a4;
  var root = React27.useRef(null);
  var firstBumper = React27.useRef(null);
  var lastBumper = React27.useRef(null);
  var mergedRootRef = useMergedRefs(root, ref);
  var doc = useDocument();
  var isFirstRender = (_a4 = usePrevious(false)) !== null && _a4 !== void 0 ? _a4 : true;
  var props = getPropsWithDefaults(DEFAULT_PROPS2, propsWithoutDefaults);
  var internalState = useConst({
    hasFocus: false,
    focusStackId: useId("ftz-", props.id)
  });
  var children = props.children, componentRef = props.componentRef, disabled = props.disabled, disableFirstFocus = props.disableFirstFocus, forceFocusInsideTrap = props.forceFocusInsideTrap, focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement, firstFocusableSelector = props.firstFocusableSelector, firstFocusableTarget = props.firstFocusableTarget, _b = props.disableRestoreFocus, disableRestoreFocus = _b === void 0 ? props.ignoreExternalFocusing : _b, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;
  var bumperProps = {
    "aria-hidden": true,
    style: {
      pointerEvents: "none",
      position: "fixed"
      // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them
    },
    tabIndex: disabled ? -1 : 0,
    "data-is-visible": true,
    "data-is-focus-trap-zone-bumper": true
  };
  var focusElementAsync = React27.useCallback(function(element) {
    if (element !== firstBumper.current && element !== lastBumper.current) {
      focusAsync(element);
    }
  }, []);
  var focusFTZ = useEventCallback(function() {
    if (!root.current) {
      return;
    }
    var previouslyFocusedElementInTrapZone = internalState.previouslyFocusedElementInTrapZone;
    if (focusPreviouslyFocusedInnerElement && previouslyFocusedElementInTrapZone && elementContains(root.current, previouslyFocusedElementInTrapZone)) {
      focusElementAsync(previouslyFocusedElementInTrapZone);
      return;
    }
    var firstFocusableChild = null;
    if (typeof firstFocusableTarget === "string") {
      firstFocusableChild = root.current.querySelector(firstFocusableTarget);
    } else if (firstFocusableTarget) {
      firstFocusableChild = firstFocusableTarget(root.current);
    } else if (firstFocusableSelector) {
      var focusSelector = typeof firstFocusableSelector === "string" ? firstFocusableSelector : firstFocusableSelector();
      firstFocusableChild = root.current.querySelector("." + focusSelector);
    }
    if (!firstFocusableChild) {
      firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);
    }
    if (firstFocusableChild) {
      focusElementAsync(firstFocusableChild);
    }
  });
  var focusBumper = function(isFirstBumper) {
    if (disabled || !root.current) {
      return;
    }
    var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, lastBumper.current, true, false) : getFirstTabbable(root.current, firstBumper.current, true, false);
    if (nextFocusable) {
      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {
        focusFTZ();
      } else {
        nextFocusable.focus();
      }
    }
  };
  var onRootBlurCapture = function(ev) {
    var _a5;
    (_a5 = props.onBlurCapture) === null || _a5 === void 0 ? void 0 : _a5.call(props, ev);
    var relatedTarget = ev.relatedTarget;
    if (ev.relatedTarget === null) {
      relatedTarget = doc.activeElement;
    }
    if (!elementContains(root.current, relatedTarget)) {
      internalState.hasFocus = false;
    }
  };
  var onRootFocusCapture = function(ev) {
    var _a5;
    (_a5 = props.onFocusCapture) === null || _a5 === void 0 ? void 0 : _a5.call(props, ev);
    if (ev.target === firstBumper.current) {
      focusBumper(true);
    } else if (ev.target === lastBumper.current) {
      focusBumper(false);
    }
    internalState.hasFocus = true;
    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {
      internalState.previouslyFocusedElementInTrapZone = ev.target;
    }
  };
  var returnFocusToInitiator = useEventCallback(function(elementToFocusOnDismiss) {
    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function(value) {
      return internalState.focusStackId !== value;
    });
    if (!doc) {
      return;
    }
    var activeElement = doc.activeElement;
    if (!disableRestoreFocus && typeof (elementToFocusOnDismiss === null || elementToFocusOnDismiss === void 0 ? void 0 : elementToFocusOnDismiss.focus) === "function" && // only restore focus if the current focused element is within the FTZ, or if nothing is focused
    (elementContains(root.current, activeElement) || activeElement === doc.body)) {
      focusElementAsync(elementToFocusOnDismiss);
    }
  });
  var forceFocusOrClickInTrap = useEventCallback(function(ev) {
    if (disabled) {
      return;
    }
    if (internalState.focusStackId === FocusTrapZone.focusStack.slice(-1)[0]) {
      var targetElement = ev.target;
      if (targetElement && !elementContains(root.current, targetElement)) {
        if (doc && doc.activeElement === doc.body) {
          setTimeout(function() {
            if (doc && doc.activeElement === doc.body) {
              focusFTZ();
              internalState.hasFocus = true;
            }
          }, 0);
        } else {
          focusFTZ();
          internalState.hasFocus = true;
        }
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  });
  React27.useEffect(function() {
    var disposables = [];
    if (forceFocusInsideTrap) {
      disposables.push(on(window, "focus", forceFocusOrClickInTrap, true));
    }
    if (!isClickableOutsideFocusTrap) {
      disposables.push(on(window, "click", forceFocusOrClickInTrap, true));
    }
    return function() {
      disposables.forEach(function(dispose) {
        return dispose();
      });
    };
  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap]);
  React27.useEffect(function() {
    if (disabled || !isFirstRender && !forceFocusInsideTrap || !root.current) {
      return;
    }
    FocusTrapZone.focusStack.push(internalState.focusStackId);
    var elementToFocusOnDismiss = props.elementToFocusOnDismiss || doc.activeElement;
    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {
      focusFTZ();
    }
    return function() {
      return returnFocusToInitiator(elementToFocusOnDismiss);
    };
  }, [forceFocusInsideTrap, disabled]);
  React27.useEffect(function() {
    if (!disabled && enableAriaHiddenSiblings) {
      var unmodalize = modalize(root.current);
      return unmodalize;
    }
  }, [disabled, enableAriaHiddenSiblings, root]);
  useUnmount(function() {
    delete internalState.previouslyFocusedElementInTrapZone;
  });
  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);
  return React27.createElement(
    "div",
    __assign({ "aria-labelledby": props.ariaLabelledBy }, getNativeProps(props, divProperties), { ref: mergedRootRef, onFocusCapture: onRootFocusCapture, onBlurCapture: onRootBlurCapture }),
    React27.createElement("div", __assign({}, bumperProps, { ref: firstBumper })),
    children,
    React27.createElement("div", __assign({}, bumperProps, { ref: lastBumper }))
  );
});
FocusTrapZone.displayName = COMPONENT_NAME2;
FocusTrapZone.focusStack = [];

// node_modules/@fluentui/react/lib/components/Callout/FocusTrapCallout.js
var FocusTrapCallout = function(props) {
  return React28.createElement(
    Callout,
    __assign({}, props),
    React28.createElement(FocusTrapZone, __assign({ disabled: props.hidden }, props.focusTrapProps), props.children)
  );
};

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.base.js
var getClassNames4 = classNamesFunction();
var TooltipBase = (
  /** @class */
  function(_super) {
    __extends(TooltipBase2, _super);
    function TooltipBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._onRenderContent = function(props) {
        if (typeof props.content === "string") {
          return React29.createElement("p", { className: _this._classNames.subText }, props.content);
        } else {
          return React29.createElement("div", { className: _this._classNames.subText }, props.content);
        }
      };
      return _this;
    }
    TooltipBase2.prototype.render = function() {
      var _a4 = this.props, className = _a4.className, calloutProps = _a4.calloutProps, directionalHint = _a4.directionalHint, directionalHintForRTL = _a4.directionalHintForRTL, styles = _a4.styles, id = _a4.id, maxWidth = _a4.maxWidth, _b = _a4.onRenderContent, onRenderContent = _b === void 0 ? this._onRenderContent : _b, targetElement = _a4.targetElement, theme = _a4.theme;
      this._classNames = getClassNames4(styles, {
        theme,
        className: className || calloutProps && calloutProps.className,
        beakWidth: calloutProps && calloutProps.isBeakVisible ? calloutProps.beakWidth : 0,
        gapSpace: calloutProps && calloutProps.gapSpace,
        maxWidth
      });
      return React29.createElement(
        Callout,
        __assign({ target: targetElement, directionalHint, directionalHintForRTL }, calloutProps, getNativeProps(this.props, divProperties, ["id"]), { className: this._classNames.root }),
        React29.createElement("div", { className: this._classNames.content, id, onFocus: this.props.onFocus, onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave }, onRenderContent(this.props, this._onRenderContent))
      );
    };
    TooltipBase2.defaultProps = {
      directionalHint: DirectionalHint.topCenter,
      maxWidth: "364px",
      calloutProps: {
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        setInitialFocus: true,
        doNotLayer: false
      }
    };
    return TooltipBase2;
  }(React29.Component)
);

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.styles.js
var getStyles4 = function(props) {
  var className = props.className, _a4 = props.beakWidth, beakWidth = _a4 === void 0 ? 16 : _a4, _b = props.gapSpace, gapSpace = _b === void 0 ? 0 : _b, maxWidth = props.maxWidth, theme = props.theme;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, effects = theme.effects;
  var tooltipGapSpace = -(Math.sqrt(beakWidth * beakWidth / 2) + gapSpace) + 1 / window.devicePixelRatio;
  return {
    root: [
      "ms-Tooltip",
      theme.fonts.medium,
      AnimationClassNames.fadeIn200,
      {
        background: semanticColors.menuBackground,
        boxShadow: effects.elevation8,
        padding: "8px",
        maxWidth,
        selectors: {
          ":after": {
            content: "''",
            position: "absolute",
            bottom: tooltipGapSpace,
            left: tooltipGapSpace,
            right: tooltipGapSpace,
            top: tooltipGapSpace,
            zIndex: 0
          }
        }
      },
      className
    ],
    content: [
      "ms-Tooltip-content",
      fonts.small,
      {
        position: "relative",
        zIndex: 1,
        color: semanticColors.menuItemText,
        wordWrap: "break-word",
        overflowWrap: "break-word",
        overflow: "hidden"
      }
    ],
    subText: [
      "ms-Tooltip-subtext",
      {
        // Using inherit here to avoid unintentional global overrides of the <p> tag.
        fontSize: "inherit",
        fontWeight: "inherit",
        color: "inherit",
        margin: 0
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.js
var Tooltip = styled(TooltipBase, getStyles4, void 0, {
  scope: "Tooltip"
});

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.types.js
var TooltipDelay;
(function(TooltipDelay2) {
  TooltipDelay2[TooltipDelay2["zero"] = 0] = "zero";
  TooltipDelay2[TooltipDelay2["medium"] = 1] = "medium";
  TooltipDelay2[TooltipDelay2["long"] = 2] = "long";
})(TooltipDelay || (TooltipDelay = {}));

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.base.js
var React30 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.types.js
var TooltipOverflowMode;
(function(TooltipOverflowMode2) {
  TooltipOverflowMode2[TooltipOverflowMode2["Parent"] = 0] = "Parent";
  TooltipOverflowMode2[TooltipOverflowMode2["Self"] = 1] = "Self";
})(TooltipOverflowMode || (TooltipOverflowMode = {}));

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.base.js
var getClassNames5 = classNamesFunction();
var TooltipHostBase = (
  /** @class */
  function(_super) {
    __extends(TooltipHostBase2, _super);
    function TooltipHostBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._tooltipHost = React30.createRef();
      _this._defaultTooltipId = getId("tooltip");
      _this.show = function() {
        _this._toggleTooltip(true);
      };
      _this.dismiss = function() {
        _this._hideTooltip();
      };
      _this._getTargetElement = function() {
        if (!_this._tooltipHost.current) {
          return void 0;
        }
        var overflowMode = _this.props.overflowMode;
        if (overflowMode !== void 0) {
          switch (overflowMode) {
            case TooltipOverflowMode.Parent:
              return _this._tooltipHost.current.parentElement;
            case TooltipOverflowMode.Self:
              return _this._tooltipHost.current;
          }
        }
        return _this._tooltipHost.current;
      };
      _this._onTooltipFocus = function(ev) {
        if (_this._ignoreNextFocusEvent) {
          _this._ignoreNextFocusEvent = false;
          return;
        }
        _this._onTooltipMouseEnter(ev);
      };
      _this._onTooltipContentFocus = function(ev) {
        if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip !== _this) {
          TooltipHostBase2._currentVisibleTooltip.dismiss();
        }
        TooltipHostBase2._currentVisibleTooltip = _this;
        _this._clearDismissTimer();
        _this._clearOpenTimer();
      };
      _this._onTooltipBlur = function(ev) {
        _this._ignoreNextFocusEvent = (document === null || document === void 0 ? void 0 : document.activeElement) === ev.target;
        _this._dismissTimerId = _this._async.setTimeout(function() {
          _this._hideTooltip();
        }, 0);
      };
      _this._onTooltipMouseEnter = function(ev) {
        var _a4 = _this.props, overflowMode = _a4.overflowMode, delay = _a4.delay;
        if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip !== _this) {
          TooltipHostBase2._currentVisibleTooltip.dismiss();
        }
        TooltipHostBase2._currentVisibleTooltip = _this;
        if (overflowMode !== void 0) {
          var overflowElement = _this._getTargetElement();
          if (overflowElement && !hasOverflow(overflowElement)) {
            return;
          }
        }
        if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {
          return;
        }
        _this._clearDismissTimer();
        _this._clearOpenTimer();
        if (delay !== TooltipDelay.zero) {
          var delayTime = _this._getDelayTime(delay);
          _this._openTimerId = _this._async.setTimeout(function() {
            _this._toggleTooltip(true);
          }, delayTime);
        } else {
          _this._toggleTooltip(true);
        }
      };
      _this._onTooltipMouseLeave = function(ev) {
        var closeDelay = _this.props.closeDelay;
        _this._clearDismissTimer();
        _this._clearOpenTimer();
        if (closeDelay) {
          _this._dismissTimerId = _this._async.setTimeout(function() {
            _this._toggleTooltip(false);
          }, closeDelay);
        } else {
          _this._toggleTooltip(false);
        }
        if (TooltipHostBase2._currentVisibleTooltip === _this) {
          TooltipHostBase2._currentVisibleTooltip = void 0;
        }
      };
      _this._onTooltipKeyDown = function(ev) {
        if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {
          _this._hideTooltip();
          ev.stopPropagation();
        }
      };
      _this._clearDismissTimer = function() {
        _this._async.clearTimeout(_this._dismissTimerId);
      };
      _this._clearOpenTimer = function() {
        _this._async.clearTimeout(_this._openTimerId);
      };
      _this._hideTooltip = function() {
        _this._clearOpenTimer();
        _this._clearDismissTimer();
        _this._toggleTooltip(false);
      };
      _this._toggleTooltip = function(isTooltipVisible) {
        if (_this.state.isTooltipVisible !== isTooltipVisible) {
          _this.setState({ isTooltipVisible }, function() {
            return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible);
          });
        }
      };
      _this._getDelayTime = function(delay) {
        switch (delay) {
          case TooltipDelay.medium:
            return 300;
          case TooltipDelay.long:
            return 500;
          default:
            return 0;
        }
      };
      initializeComponentRef(_this);
      _this.state = {
        isAriaPlaceholderRendered: false,
        isTooltipVisible: false
      };
      _this._async = new Async(_this);
      return _this;
    }
    TooltipHostBase2.prototype.render = function() {
      var _a4 = this.props, calloutProps = _a4.calloutProps, children = _a4.children, content = _a4.content, directionalHint = _a4.directionalHint, directionalHintForRTL = _a4.directionalHintForRTL, className = _a4.hostClassName, id = _a4.id, _b = _a4.setAriaDescribedBy, setAriaDescribedBy = _b === void 0 ? true : _b, tooltipProps = _a4.tooltipProps, styles = _a4.styles, theme = _a4.theme;
      this._classNames = getClassNames5(styles, {
        theme,
        className
      });
      var isTooltipVisible = this.state.isTooltipVisible;
      var tooltipId = id || this._defaultTooltipId;
      var tooltipRenderProps = __assign(__assign({ id: tooltipId + "--tooltip", content, targetElement: this._getTargetElement(), directionalHint, directionalHintForRTL, calloutProps: assign({}, calloutProps, {
        onDismiss: this._hideTooltip,
        onFocus: this._onTooltipContentFocus,
        onMouseEnter: this._onTooltipMouseEnter,
        onMouseLeave: this._onTooltipMouseLeave
      }), onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave }, getNativeProps(this.props, divProperties, ["id"])), tooltipProps);
      var tooltipContent = (tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.onRenderContent) ? tooltipProps.onRenderContent(tooltipRenderProps, function(props) {
        return (props === null || props === void 0 ? void 0 : props.content) ? React30.createElement(React30.Fragment, null, props.content) : null;
      }) : content;
      var showTooltip = isTooltipVisible && !!tooltipContent;
      var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && !!tooltipContent ? tooltipId : void 0;
      return React30.createElement(
        "div",
        __assign({ className: this._classNames.root, ref: this._tooltipHost }, { onFocusCapture: this._onTooltipFocus }, { onBlurCapture: this._onTooltipBlur }, { onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave, onKeyDown: this._onTooltipKeyDown, role: "none", "aria-describedby": ariaDescribedBy }),
        children,
        showTooltip && React30.createElement(Tooltip, __assign({}, tooltipRenderProps)),
        React30.createElement("div", { hidden: true, id: tooltipId, style: hiddenContentStyle }, tooltipContent)
      );
    };
    TooltipHostBase2.prototype.componentWillUnmount = function() {
      if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip === this) {
        TooltipHostBase2._currentVisibleTooltip = void 0;
      }
      this._async.dispose();
    };
    TooltipHostBase2.defaultProps = {
      delay: TooltipDelay.medium
    };
    return TooltipHostBase2;
  }(React30.Component)
);

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.styles.js
var GlobalClassNames4 = {
  root: "ms-TooltipHost",
  ariaPlaceholder: "ms-TooltipHost-aria-placeholder"
};
var getStyles5 = function(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames4, theme);
  return {
    root: [
      classNames2.root,
      {
        display: "inline"
      },
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.js
var TooltipHost = styled(TooltipHostBase, getStyles5, void 0, {
  scope: "TooltipHost"
});

// node_modules/@fluentui/react/lib/components/Persona/PersonaCoin/PersonaCoin.base.js
var React36 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Persona/PersonaPresence/PersonaPresence.base.js
var React35 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.base.js
var React33 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.types.js
var IconType;
(function(IconType2) {
  IconType2[IconType2["default"] = 0] = "default";
  IconType2[IconType2["image"] = 1] = "image";
  IconType2[IconType2["Default"] = 1e5] = "Default";
  IconType2[IconType2["Image"] = 100001] = "Image";
})(IconType || (IconType = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.base.js
var React31 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Image/Image.types.js
var ImageFit;
(function(ImageFit2) {
  ImageFit2[ImageFit2["center"] = 0] = "center";
  ImageFit2[ImageFit2["contain"] = 1] = "contain";
  ImageFit2[ImageFit2["cover"] = 2] = "cover";
  ImageFit2[ImageFit2["none"] = 3] = "none";
  ImageFit2[ImageFit2["centerCover"] = 4] = "centerCover";
  ImageFit2[ImageFit2["centerContain"] = 5] = "centerContain";
})(ImageFit || (ImageFit = {}));
var ImageCoverStyle;
(function(ImageCoverStyle2) {
  ImageCoverStyle2[ImageCoverStyle2["landscape"] = 0] = "landscape";
  ImageCoverStyle2[ImageCoverStyle2["portrait"] = 1] = "portrait";
})(ImageCoverStyle || (ImageCoverStyle = {}));
var ImageLoadState;
(function(ImageLoadState2) {
  ImageLoadState2[ImageLoadState2["notLoaded"] = 0] = "notLoaded";
  ImageLoadState2[ImageLoadState2["loaded"] = 1] = "loaded";
  ImageLoadState2[ImageLoadState2["error"] = 2] = "error";
  ImageLoadState2[ImageLoadState2["errorLoaded"] = 3] = "errorLoaded";
})(ImageLoadState || (ImageLoadState = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.base.js
var getClassNames6 = classNamesFunction();
var SVG_REGEX = /\.svg$/i;
var KEY_PREFIX = "fabricImage";
function useLoadState(props, imageElement) {
  var onLoadingStateChange = props.onLoadingStateChange, onLoad = props.onLoad, onError = props.onError, src = props.src;
  var _a4 = React31.useState(ImageLoadState.notLoaded), loadState = _a4[0], setLoadState = _a4[1];
  useIsomorphicLayoutEffect(function() {
    setLoadState(ImageLoadState.notLoaded);
  }, [src]);
  React31.useEffect(function() {
    if (loadState === ImageLoadState.notLoaded) {
      var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;
      if (isLoaded) {
        setLoadState(ImageLoadState.loaded);
      }
    }
  });
  React31.useEffect(function() {
    onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState);
  }, [loadState]);
  var onImageLoaded = React31.useCallback(function(ev) {
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);
    if (src) {
      setLoadState(ImageLoadState.loaded);
    }
  }, [src, onLoad]);
  var onImageError = React31.useCallback(function(ev) {
    onError === null || onError === void 0 ? void 0 : onError(ev);
    setLoadState(ImageLoadState.error);
  }, [onError]);
  return [loadState, onImageLoaded, onImageError];
}
var ImageBase = React31.forwardRef(function(props, forwardedRef) {
  var frameElement = React31.useRef();
  var imageElement = React31.useRef();
  var _a4 = useLoadState(props, imageElement), loadState = _a4[0], onImageLoaded = _a4[1], onImageError = _a4[2];
  var imageProps = getNativeProps(props, imgProperties, [
    "width",
    "height"
  ]);
  var src = props.src, alt = props.alt, width = props.width, height = props.height, _b = props.shouldFadeIn, shouldFadeIn = _b === void 0 ? true : _b, shouldStartVisible = props.shouldStartVisible, className = props.className, imageFit = props.imageFit, role = props.role, maximizeFrame = props.maximizeFrame, styles = props.styles, theme = props.theme, loading = props.loading;
  var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);
  var classNames2 = getClassNames6(styles, {
    theme,
    className,
    width,
    height,
    maximizeFrame,
    shouldFadeIn,
    shouldStartVisible,
    isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,
    isLandscape: coverStyle === ImageCoverStyle.landscape,
    isCenter: imageFit === ImageFit.center,
    isCenterContain: imageFit === ImageFit.centerContain,
    isCenterCover: imageFit === ImageFit.centerCover,
    isContain: imageFit === ImageFit.contain,
    isCover: imageFit === ImageFit.cover,
    isNone: imageFit === ImageFit.none,
    isError: loadState === ImageLoadState.error,
    isNotImageFit: imageFit === void 0
  });
  return React31.createElement(
    "div",
    { className: classNames2.root, style: { width, height }, ref: frameElement },
    React31.createElement("img", __assign({}, imageProps, { onLoad: onImageLoaded, onError: onImageError, key: KEY_PREFIX + props.src || "", className: classNames2.image, ref: useMergedRefs(imageElement, forwardedRef), src, alt, role, loading }))
  );
});
ImageBase.displayName = "ImageBase";
function useCoverStyle(props, loadState, imageElement, frameElement) {
  var previousLoadState = React31.useRef(loadState);
  var coverStyle = React31.useRef();
  if (coverStyle === void 0 || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {
    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);
  }
  previousLoadState.current = loadState;
  return coverStyle.current;
}
function computeCoverStyle(props, loadState, imageElement, frameElement) {
  var imageFit = props.imageFit, width = props.width, height = props.height;
  if (props.coverStyle !== void 0) {
    return props.coverStyle;
  } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {
    var desiredRatio = void 0;
    if (typeof width === "number" && typeof height === "number" && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {
      desiredRatio = width / height;
    } else {
      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;
    }
    var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;
    if (naturalRatio > desiredRatio) {
      return ImageCoverStyle.landscape;
    }
  }
  return ImageCoverStyle.portrait;
}

// node_modules/@fluentui/react/lib/components/Image/Image.styles.js
var GlobalClassNames5 = {
  root: "ms-Image",
  rootMaximizeFrame: "ms-Image--maximizeFrame",
  image: "ms-Image-image",
  imageCenter: "ms-Image-image--center",
  imageContain: "ms-Image-image--contain",
  imageCover: "ms-Image-image--cover",
  imageCenterContain: "ms-Image-image--centerContain",
  imageCenterCover: "ms-Image-image--centerCover",
  imageNone: "ms-Image-image--none",
  imageLandscape: "ms-Image-image--landscape",
  imagePortrait: "ms-Image-image--portrait"
};
var getStyles6 = function(props) {
  var className = props.className, width = props.width, height = props.height, maximizeFrame = props.maximizeFrame, isLoaded = props.isLoaded, shouldFadeIn = props.shouldFadeIn, shouldStartVisible = props.shouldStartVisible, isLandscape = props.isLandscape, isCenter = props.isCenter, isContain = props.isContain, isCover = props.isCover, isCenterContain = props.isCenterContain, isCenterCover = props.isCenterCover, isNone = props.isNone, isError = props.isError, isNotImageFit = props.isNotImageFit, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames5, theme);
  var ImageFitStyles = {
    position: "absolute",
    left: "50% /* @noflip */",
    top: "50%",
    transform: "translate(-50%,-50%)"
    // @todo test RTL renders transform: translate(50%,-50%);
  };
  var window2 = getWindow();
  var supportsObjectFit = window2 !== void 0 && window2.navigator.msMaxTouchPoints === void 0;
  var fallbackObjectFitStyles = isContain && isLandscape || isCover && !isLandscape ? { width: "100%", height: "auto" } : { width: "auto", height: "100%" };
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        overflow: "hidden"
      },
      maximizeFrame && [
        classNames2.rootMaximizeFrame,
        {
          height: "100%",
          width: "100%"
        }
      ],
      isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
      (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {
        position: "relative"
      },
      className
    ],
    image: [
      classNames2.image,
      {
        display: "block",
        opacity: 0
      },
      isLoaded && [
        "is-loaded",
        {
          opacity: 1
        }
      ],
      isCenter && [classNames2.imageCenter, ImageFitStyles],
      isContain && [
        classNames2.imageContain,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCover && [
        classNames2.imageCover,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "cover"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCenterContain && [
        classNames2.imageCenterContain,
        isLandscape && {
          maxWidth: "100%"
        },
        !isLandscape && {
          maxHeight: "100%"
        },
        ImageFitStyles
      ],
      isCenterCover && [
        classNames2.imageCenterCover,
        isLandscape && {
          maxHeight: "100%"
        },
        !isLandscape && {
          maxWidth: "100%"
        },
        ImageFitStyles
      ],
      isNone && [
        classNames2.imageNone,
        {
          width: "auto",
          height: "auto"
        }
      ],
      isNotImageFit && [
        !!width && !height && {
          height: "auto",
          width: "100%"
        },
        !width && !!height && {
          height: "100%",
          width: "auto"
        },
        !!width && !!height && {
          height: "100%",
          width: "100%"
        }
      ],
      isLandscape && classNames2.imageLandscape,
      !isLandscape && classNames2.imagePortrait,
      !isLoaded && "is-notLoaded",
      shouldFadeIn && "is-fadeIn",
      isError && "is-error"
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Image/Image.js
var Image = styled(ImageBase, getStyles6, void 0, {
  scope: "Image"
}, true);
Image.displayName = "Image";

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var React32 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.styles.js
var classNames = mergeStyleSets({
  root: {
    display: "inline-block"
  },
  placeholder: [
    "ms-Icon-placeHolder",
    {
      width: "1em"
    }
  ],
  image: [
    "ms-Icon-imageContainer",
    {
      overflow: "hidden"
    }
  ]
});
var MS_ICON = "ms-Icon";
var getStyles7 = function(props) {
  var className = props.className, iconClassName = props.iconClassName, isPlaceholder = props.isPlaceholder, isImage = props.isImage, styles = props.styles;
  return {
    root: [
      isPlaceholder && classNames.placeholder,
      classNames.root,
      isImage && classNames.image,
      iconClassName,
      className,
      styles && styles.root,
      // eslint-disable-next-line deprecation/deprecation
      styles && styles.imageContainer
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var getIconContent = memoizeFunction(
  function(iconName) {
    var _a4 = getIcon(iconName) || {
      subset: {},
      code: void 0
    }, code = _a4.code, subset = _a4.subset;
    if (!code) {
      return null;
    }
    return {
      children: code,
      iconClassName: subset.className,
      fontFamily: subset.fontFace && subset.fontFace.fontFamily,
      mergeImageProps: subset.mergeImageProps
    };
  },
  void 0,
  true
  /*ignoreNullOrUndefinedResult */
);
var FontIcon = function(props) {
  var iconName = props.iconName, className = props.className, _a4 = props.style, style = _a4 === void 0 ? {} : _a4;
  var iconContent = getIconContent(iconName) || {};
  var iconClassName = iconContent.iconClassName, children = iconContent.children, fontFamily = iconContent.fontFamily, mergeImageProps = iconContent.mergeImageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties);
  var accessibleName = props["aria-label"] || props.title;
  var containerProps = props["aria-label"] || props["aria-labelledby"] || props.title ? {
    role: mergeImageProps ? void 0 : "img"
  } : {
    "aria-hidden": true
  };
  var finalChildren = children;
  if (mergeImageProps) {
    if (typeof children === "object" && typeof children.props === "object" && accessibleName) {
      finalChildren = React32.cloneElement(children, { alt: accessibleName });
    }
  }
  return React32.createElement("i", __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
    title: void 0,
    "aria-label": void 0
  } : {}, {
    className: css(MS_ICON, classNames.root, iconClassName, !iconName && classNames.placeholder, className),
    // Apply the font family this way to ensure it doesn't get overridden by Fabric Core ms-Icon styles
    // https://github.com/microsoft/fluentui/issues/10449
    style: __assign({ fontFamily }, style)
  }), finalChildren);
};
var getFontIcon = memoizeFunction(function(iconName, className, ariaLabel) {
  return FontIcon({ iconName, className, "aria-label": ariaLabel });
});

// node_modules/@fluentui/react/lib/components/Icon/Icon.base.js
var getClassNames7 = classNamesFunction({
  // Icon is used a lot by other components.
  // It's likely to see expected cases which pass different className to the Icon.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._onImageLoadingStateChange = function(state) {
        if (_this.props.imageProps && _this.props.imageProps.onLoadingStateChange) {
          _this.props.imageProps.onLoadingStateChange(state);
        }
        if (state === ImageLoadState.error) {
          _this.setState({ imageLoadError: true });
        }
      };
      _this.state = {
        imageLoadError: false
      };
      return _this;
    }
    IconBase2.prototype.render = function() {
      var _a4 = this.props, children = _a4.children, className = _a4.className, styles = _a4.styles, iconName = _a4.iconName, imageErrorAs = _a4.imageErrorAs, theme = _a4.theme;
      var isPlaceholder = typeof iconName === "string" && iconName.length === 0;
      var isImage = (
        // eslint-disable-next-line deprecation/deprecation
        !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image
      );
      var iconContent = getIconContent(iconName) || {};
      var iconClassName = iconContent.iconClassName, iconContentChildren = iconContent.children, mergeImageProps = iconContent.mergeImageProps;
      var classNames2 = getClassNames7(styles, {
        theme,
        className,
        iconClassName,
        isImage,
        isPlaceholder
      });
      var RootType = isImage ? "span" : "i";
      var nativeProps = getNativeProps(this.props, htmlElementProperties, [
        "aria-label"
      ]);
      var imageLoadError = this.state.imageLoadError;
      var imageProps = __assign(__assign({}, this.props.imageProps), { onLoadingStateChange: this._onImageLoadingStateChange });
      var ImageType = imageLoadError && imageErrorAs || Image;
      var ariaLabel = this.props["aria-label"] || this.props.ariaLabel;
      var accessibleName = imageProps.alt || ariaLabel || this.props.title;
      var hasName = !!(accessibleName || this.props["aria-labelledby"] || imageProps["aria-label"] || imageProps["aria-labelledby"]);
      var containerProps = hasName ? {
        role: isImage || mergeImageProps ? void 0 : "img",
        "aria-label": isImage || mergeImageProps ? void 0 : accessibleName
      } : {
        "aria-hidden": true
      };
      var finalIconContentChildren = iconContentChildren;
      if (mergeImageProps && iconContentChildren && typeof iconContentChildren === "object" && accessibleName) {
        finalIconContentChildren = React33.cloneElement(iconContentChildren, {
          alt: accessibleName
        });
      }
      return React33.createElement(RootType, __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
        title: void 0,
        "aria-label": void 0
      } : {}, { className: classNames2.root }), isImage ? React33.createElement(ImageType, __assign({}, imageProps)) : children || finalIconContentChildren);
    };
    return IconBase2;
  }(React33.Component)
);

// node_modules/@fluentui/react/lib/components/Icon/Icon.js
var Icon = styled(IconBase, getStyles7, void 0, {
  scope: "Icon"
}, true);
Icon.displayName = "Icon";

// node_modules/@fluentui/react/lib/components/Icon/ImageIcon.js
var React34 = __toESM(require_react());
var ImageIcon = function(props) {
  var className = props.className, imageProps = props.imageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties, [
    "aria-label",
    "aria-labelledby",
    "title",
    "aria-describedby"
  ]);
  var altText = imageProps.alt || props["aria-label"];
  var hasName = altText || props["aria-labelledby"] || props.title || imageProps["aria-label"] || imageProps["aria-labelledby"] || imageProps.title;
  var imageNameProps = {
    "aria-labelledby": props["aria-labelledby"],
    "aria-describedby": props["aria-describedby"],
    title: props.title
  };
  var containerProps = hasName ? {} : {
    "aria-hidden": true
  };
  return React34.createElement(
    "div",
    __assign({}, containerProps, nativeProps, { className: css(MS_ICON, classNames.root, classNames.image, className) }),
    React34.createElement(Image, __assign({}, imageNameProps, imageProps, { alt: hasName ? altText : "" }))
  );
};

// node_modules/@fluentui/react/lib/components/Persona/Persona.types.js
var PersonaSize;
(function(PersonaSize2) {
  PersonaSize2[PersonaSize2["tiny"] = 0] = "tiny";
  PersonaSize2[PersonaSize2["extraExtraSmall"] = 1] = "extraExtraSmall";
  PersonaSize2[PersonaSize2["extraSmall"] = 2] = "extraSmall";
  PersonaSize2[PersonaSize2["small"] = 3] = "small";
  PersonaSize2[PersonaSize2["regular"] = 4] = "regular";
  PersonaSize2[PersonaSize2["large"] = 5] = "large";
  PersonaSize2[PersonaSize2["extraLarge"] = 6] = "extraLarge";
  PersonaSize2[PersonaSize2["size8"] = 17] = "size8";
  PersonaSize2[PersonaSize2["size10"] = 9] = "size10";
  PersonaSize2[PersonaSize2["size16"] = 8] = "size16";
  PersonaSize2[PersonaSize2["size24"] = 10] = "size24";
  PersonaSize2[PersonaSize2["size28"] = 7] = "size28";
  PersonaSize2[PersonaSize2["size32"] = 11] = "size32";
  PersonaSize2[PersonaSize2["size40"] = 12] = "size40";
  PersonaSize2[PersonaSize2["size48"] = 13] = "size48";
  PersonaSize2[PersonaSize2["size56"] = 16] = "size56";
  PersonaSize2[PersonaSize2["size72"] = 14] = "size72";
  PersonaSize2[PersonaSize2["size100"] = 15] = "size100";
  PersonaSize2[PersonaSize2["size120"] = 18] = "size120";
})(PersonaSize || (PersonaSize = {}));
var PersonaPresence;
(function(PersonaPresence3) {
  PersonaPresence3[PersonaPresence3["none"] = 0] = "none";
  PersonaPresence3[PersonaPresence3["offline"] = 1] = "offline";
  PersonaPresence3[PersonaPresence3["online"] = 2] = "online";
  PersonaPresence3[PersonaPresence3["away"] = 3] = "away";
  PersonaPresence3[PersonaPresence3["dnd"] = 4] = "dnd";
  PersonaPresence3[PersonaPresence3["blocked"] = 5] = "blocked";
  PersonaPresence3[PersonaPresence3["busy"] = 6] = "busy";
})(PersonaPresence || (PersonaPresence = {}));
var PersonaInitialsColor;
(function(PersonaInitialsColor2) {
  PersonaInitialsColor2[PersonaInitialsColor2["lightBlue"] = 0] = "lightBlue";
  PersonaInitialsColor2[PersonaInitialsColor2["blue"] = 1] = "blue";
  PersonaInitialsColor2[PersonaInitialsColor2["darkBlue"] = 2] = "darkBlue";
  PersonaInitialsColor2[PersonaInitialsColor2["teal"] = 3] = "teal";
  PersonaInitialsColor2[PersonaInitialsColor2["lightGreen"] = 4] = "lightGreen";
  PersonaInitialsColor2[PersonaInitialsColor2["green"] = 5] = "green";
  PersonaInitialsColor2[PersonaInitialsColor2["darkGreen"] = 6] = "darkGreen";
  PersonaInitialsColor2[PersonaInitialsColor2["lightPink"] = 7] = "lightPink";
  PersonaInitialsColor2[PersonaInitialsColor2["pink"] = 8] = "pink";
  PersonaInitialsColor2[PersonaInitialsColor2["magenta"] = 9] = "magenta";
  PersonaInitialsColor2[PersonaInitialsColor2["purple"] = 10] = "purple";
  PersonaInitialsColor2[PersonaInitialsColor2["black"] = 11] = "black";
  PersonaInitialsColor2[PersonaInitialsColor2["orange"] = 12] = "orange";
  PersonaInitialsColor2[PersonaInitialsColor2["red"] = 13] = "red";
  PersonaInitialsColor2[PersonaInitialsColor2["darkRed"] = 14] = "darkRed";
  PersonaInitialsColor2[PersonaInitialsColor2["transparent"] = 15] = "transparent";
  PersonaInitialsColor2[PersonaInitialsColor2["violet"] = 16] = "violet";
  PersonaInitialsColor2[PersonaInitialsColor2["lightRed"] = 17] = "lightRed";
  PersonaInitialsColor2[PersonaInitialsColor2["gold"] = 18] = "gold";
  PersonaInitialsColor2[PersonaInitialsColor2["burgundy"] = 19] = "burgundy";
  PersonaInitialsColor2[PersonaInitialsColor2["warmGray"] = 20] = "warmGray";
  PersonaInitialsColor2[PersonaInitialsColor2["coolGray"] = 21] = "coolGray";
  PersonaInitialsColor2[PersonaInitialsColor2["gray"] = 22] = "gray";
  PersonaInitialsColor2[PersonaInitialsColor2["cyan"] = 23] = "cyan";
  PersonaInitialsColor2[PersonaInitialsColor2["rust"] = 24] = "rust";
})(PersonaInitialsColor || (PersonaInitialsColor = {}));

// node_modules/@fluentui/react/lib/components/Persona/PersonaConsts.js
var _a3;
var personaSize;
(function(personaSize2) {
  personaSize2.size8 = "20px";
  personaSize2.size10 = "20px";
  personaSize2.size16 = "16px";
  personaSize2.size24 = "24px";
  personaSize2.size28 = "28px";
  personaSize2.size32 = "32px";
  personaSize2.size40 = "40px";
  personaSize2.size48 = "48px";
  personaSize2.size56 = "56px";
  personaSize2.size72 = "72px";
  personaSize2.size100 = "100px";
  personaSize2.size120 = "120px";
})(personaSize || (personaSize = {}));
var personaPresenceSize;
(function(personaPresenceSize2) {
  personaPresenceSize2.size6 = "6px";
  personaPresenceSize2.size8 = "8px";
  personaPresenceSize2.size12 = "12px";
  personaPresenceSize2.size16 = "16px";
  personaPresenceSize2.size20 = "20px";
  personaPresenceSize2.size28 = "28px";
  personaPresenceSize2.size32 = "32px";
  personaPresenceSize2.border = "2px";
})(personaPresenceSize || (personaPresenceSize = {}));
var sizeBoolean = function(size) {
  return {
    isSize8: size === PersonaSize.size8,
    /* eslint-disable deprecation/deprecation */
    isSize10: size === PersonaSize.size10 || size === PersonaSize.tiny,
    isSize16: size === PersonaSize.size16,
    isSize24: size === PersonaSize.size24 || size === PersonaSize.extraExtraSmall,
    isSize28: size === PersonaSize.size28 || size === PersonaSize.extraSmall,
    isSize32: size === PersonaSize.size32,
    isSize40: size === PersonaSize.size40 || size === PersonaSize.small,
    isSize48: size === PersonaSize.size48 || size === PersonaSize.regular,
    isSize56: size === PersonaSize.size56,
    isSize72: size === PersonaSize.size72 || size === PersonaSize.large,
    isSize100: size === PersonaSize.size100 || size === PersonaSize.extraLarge,
    isSize120: size === PersonaSize.size120
  };
};
var sizeToPixels = (_a3 = {}, // Old deprecated sizes
_a3[PersonaSize.tiny] = 10, _a3[PersonaSize.extraExtraSmall] = 24, _a3[PersonaSize.extraSmall] = 28, _a3[PersonaSize.small] = 40, _a3[PersonaSize.regular] = 48, _a3[PersonaSize.large] = 72, _a3[PersonaSize.extraLarge] = 100, // New sizes
_a3[PersonaSize.size8] = 8, _a3[PersonaSize.size10] = 10, _a3[PersonaSize.size16] = 16, _a3[PersonaSize.size24] = 24, _a3[PersonaSize.size28] = 28, /* eslint-enable deprecation/deprecation */
_a3[PersonaSize.size32] = 32, _a3[PersonaSize.size40] = 40, _a3[PersonaSize.size48] = 48, _a3[PersonaSize.size56] = 56, _a3[PersonaSize.size72] = 72, _a3[PersonaSize.size100] = 100, _a3[PersonaSize.size120] = 120, _a3);
var presenceBoolean = function(presence) {
  return {
    isAvailable: presence === PersonaPresence.online,
    isAway: presence === PersonaPresence.away,
    isBlocked: presence === PersonaPresence.blocked,
    isBusy: presence === PersonaPresence.busy,
    isDoNotDisturb: presence === PersonaPresence.dnd,
    isOffline: presence === PersonaPresence.offline
  };
};

// node_modules/@fluentui/react/lib/components/Persona/PersonaPresence/PersonaPresence.base.js
var coinSizeFontScaleFactor = 6;
var coinSizePresenceScaleFactor = 3;
var presenceMaxSize = 40;
var presenceFontMaxSize = 20;
var getClassNames8 = classNamesFunction({
  // There can be many PersonaPresence rendered with different sizes.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var PersonaPresenceBase = React35.forwardRef(function(props, forwardedRef) {
  var coinSize = props.coinSize, isOutOfOffice = props.isOutOfOffice, styles = props.styles, presence = props.presence, theme = props.theme, presenceTitle = props.presenceTitle, presenceColors = props.presenceColors;
  var rootRef = React35.useRef(null);
  var mergedRootRef = useMergedRefs(forwardedRef, rootRef);
  var size = sizeBoolean(props.size);
  var renderIcon = !(size.isSize8 || size.isSize10 || size.isSize16 || size.isSize24 || size.isSize28 || size.isSize32) && (coinSize ? coinSize > 32 : true);
  var presenceHeightWidth = coinSize ? coinSize / coinSizePresenceScaleFactor < presenceMaxSize ? coinSize / coinSizePresenceScaleFactor + "px" : presenceMaxSize + "px" : "";
  var presenceFontSize = coinSize ? coinSize / coinSizeFontScaleFactor < presenceFontMaxSize ? coinSize / coinSizeFontScaleFactor + "px" : presenceFontMaxSize + "px" : "";
  var coinSizeWithPresenceIconStyle = coinSize ? { fontSize: presenceFontSize, lineHeight: presenceHeightWidth } : void 0;
  var coinSizeWithPresenceStyle = coinSize ? { width: presenceHeightWidth, height: presenceHeightWidth } : void 0;
  var classNames2 = getClassNames8(styles, {
    theme,
    presence,
    size: props.size,
    isOutOfOffice,
    presenceColors
  });
  if (presence === PersonaPresence.none) {
    return null;
  }
  return React35.createElement("div", { role: "presentation", className: classNames2.presence, style: coinSizeWithPresenceStyle, title: presenceTitle, ref: mergedRootRef }, renderIcon && React35.createElement(Icon, { className: classNames2.presenceIcon, iconName: determineIcon(props.presence, props.isOutOfOffice), style: coinSizeWithPresenceIconStyle }));
});
PersonaPresenceBase.displayName = "PersonaPresenceBase";
function determineIcon(presence, isOutOfOffice) {
  if (!presence) {
    return void 0;
  }
  var oofIcon = "SkypeArrow";
  switch (PersonaPresence[presence]) {
    case "online":
      return "SkypeCheck";
    case "away":
      return isOutOfOffice ? oofIcon : "SkypeClock";
    case "dnd":
      return "SkypeMinus";
    case "offline":
      return isOutOfOffice ? oofIcon : "";
  }
  return "";
}

// node_modules/@fluentui/react/lib/components/Persona/PersonaPresence/PersonaPresence.styles.js
var GlobalClassNames6 = {
  presence: "ms-Persona-presence",
  presenceIcon: "ms-Persona-presenceIcon"
};
var getStyles8 = function(props) {
  var _a4, _b, _c, _d, _e, _f;
  var theme = props.theme, presenceColors = props.presenceColors;
  var semanticColors = theme.semanticColors, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames6, theme);
  var size = sizeBoolean(props.size);
  var presence = presenceBoolean(props.presence);
  var presenceColorAvailable = presenceColors && presenceColors.available || "#6BB700";
  var presenceColorAway = presenceColors && presenceColors.away || "#FFAA44";
  var presenceColorBusy = presenceColors && presenceColors.busy || "#C43148";
  var presenceColorDnd = presenceColors && presenceColors.dnd || "#C50F1F";
  var presenceColorOffline = presenceColors && presenceColors.offline || "#8A8886";
  var presenceColorOof = presenceColors && presenceColors.oof || "#B4009E";
  var presenceColorBackground = presenceColors && presenceColors.background || semanticColors.bodyBackground;
  var isOpenCirclePresence = presence.isOffline || props.isOutOfOffice && (presence.isAvailable || presence.isBusy || presence.isAway || presence.isDoNotDisturb);
  var borderSizeForSmallPersonas = "1px";
  var borderSizeForLargePersonas = "2px";
  var borderSize = size.isSize72 || size.isSize100 ? borderSizeForLargePersonas : borderSizeForSmallPersonas;
  return {
    presence: [
      classNames2.presence,
      __assign(__assign({ position: "absolute", height: personaPresenceSize.size12, width: personaPresenceSize.size12, borderRadius: "50%", top: "auto", right: "-2px", bottom: "-2px", border: "2px solid " + presenceColorBackground, textAlign: "center", boxSizing: "content-box", backgroundClip: "border-box" }, getHighContrastNoAdjustStyle()), { selectors: (_a4 = {}, _a4[HighContrastSelector] = {
        borderColor: "Window",
        backgroundColor: "WindowText"
      }, _a4) }),
      (size.isSize8 || size.isSize10) && {
        right: "auto",
        top: "7px",
        left: 0,
        border: 0,
        selectors: (_b = {}, _b[HighContrastSelector] = {
          top: "9px",
          border: "1px solid WindowText"
        }, _b)
      },
      (size.isSize8 || size.isSize10 || size.isSize24 || size.isSize28 || size.isSize32) && makeSizeStyle(personaPresenceSize.size8),
      (size.isSize40 || size.isSize48) && makeSizeStyle(personaPresenceSize.size12),
      size.isSize16 && {
        height: personaPresenceSize.size6,
        width: personaPresenceSize.size6,
        borderWidth: "1.5px"
      },
      size.isSize56 && makeSizeStyle(personaPresenceSize.size16),
      size.isSize72 && makeSizeStyle(personaPresenceSize.size20),
      size.isSize100 && makeSizeStyle(personaPresenceSize.size28),
      size.isSize120 && makeSizeStyle(personaPresenceSize.size32),
      presence.isAvailable && {
        backgroundColor: presenceColorAvailable,
        selectors: (_c = {}, _c[HighContrastSelector] = backgroundColor("Highlight"), _c)
      },
      presence.isAway && backgroundColor(presenceColorAway),
      presence.isBlocked && [
        {
          selectors: (_d = {
            // Only show :after at larger sizes
            ":after": size.isSize40 || size.isSize48 || size.isSize72 || size.isSize100 ? {
              content: '""',
              width: "100%",
              height: borderSize,
              backgroundColor: presenceColorBusy,
              transform: "translateY(-50%) rotate(-45deg)",
              position: "absolute",
              top: "50%",
              left: 0
            } : void 0
          }, _d[HighContrastSelector] = {
            selectors: {
              ":after": {
                width: "calc(100% - 4px)",
                left: "2px",
                backgroundColor: "Window"
              }
            }
          }, _d)
        }
      ],
      presence.isBusy && backgroundColor(presenceColorBusy),
      presence.isDoNotDisturb && backgroundColor(presenceColorDnd),
      presence.isOffline && backgroundColor(presenceColorOffline),
      (isOpenCirclePresence || presence.isBlocked) && [
        {
          backgroundColor: presenceColorBackground,
          selectors: (_e = {
            ":before": {
              content: '""',
              width: "100%",
              height: "100%",
              position: "absolute",
              top: 0,
              left: 0,
              border: borderSize + " solid " + presenceColorBusy,
              borderRadius: "50%",
              boxSizing: "border-box"
            }
          }, _e[HighContrastSelector] = {
            backgroundColor: "WindowText",
            selectors: {
              ":before": {
                width: "calc(100% - 2px)",
                height: "calc(100% - 2px)",
                top: "1px",
                left: "1px",
                borderColor: "Window"
              }
            }
          }, _e)
        }
      ],
      isOpenCirclePresence && presence.isAvailable && makeBeforeBorderStyle(borderSize, presenceColorAvailable),
      isOpenCirclePresence && presence.isBusy && makeBeforeBorderStyle(borderSize, presenceColorBusy),
      isOpenCirclePresence && presence.isAway && makeBeforeBorderStyle(borderSize, presenceColorOof),
      isOpenCirclePresence && presence.isDoNotDisturb && makeBeforeBorderStyle(borderSize, presenceColorDnd),
      isOpenCirclePresence && presence.isOffline && makeBeforeBorderStyle(borderSize, presenceColorOffline),
      isOpenCirclePresence && presence.isOffline && props.isOutOfOffice && makeBeforeBorderStyle(borderSize, presenceColorOof)
    ],
    presenceIcon: [
      classNames2.presenceIcon,
      {
        color: presenceColorBackground,
        fontSize: "6px",
        lineHeight: personaPresenceSize.size12,
        verticalAlign: "top",
        selectors: (_f = {}, _f[HighContrastSelector] = {
          color: "Window"
        }, _f)
      },
      size.isSize56 && {
        fontSize: "8px",
        lineHeight: personaPresenceSize.size16
      },
      size.isSize72 && {
        fontSize: fonts.small.fontSize,
        lineHeight: personaPresenceSize.size20
      },
      size.isSize100 && {
        fontSize: fonts.medium.fontSize,
        lineHeight: personaPresenceSize.size28
      },
      size.isSize120 && {
        fontSize: fonts.medium.fontSize,
        lineHeight: personaPresenceSize.size32
      },
      presence.isAway && {
        position: "relative",
        left: isOpenCirclePresence ? void 0 : "1px"
      },
      isOpenCirclePresence && presence.isAvailable && makeOpenCircleIconStyle(presenceColorAvailable),
      isOpenCirclePresence && presence.isBusy && makeOpenCircleIconStyle(presenceColorBusy),
      isOpenCirclePresence && presence.isAway && makeOpenCircleIconStyle(presenceColorOof),
      isOpenCirclePresence && presence.isDoNotDisturb && makeOpenCircleIconStyle(presenceColorDnd),
      isOpenCirclePresence && presence.isOffline && makeOpenCircleIconStyle(presenceColorOffline),
      isOpenCirclePresence && presence.isOffline && props.isOutOfOffice && makeOpenCircleIconStyle(presenceColorOof)
    ]
  };
};
function makeOpenCircleIconStyle(color) {
  return {
    color,
    borderColor: color
  };
}
function makeBeforeBorderStyle(borderSize, color) {
  return {
    selectors: {
      ":before": {
        border: borderSize + " solid " + color
      }
    }
  };
}
function makeSizeStyle(size) {
  return {
    height: size,
    width: size
  };
}
function backgroundColor(color) {
  return { backgroundColor: color };
}

// node_modules/@fluentui/react/lib/components/Persona/PersonaPresence/PersonaPresence.js
var PersonaPresence2 = styled(PersonaPresenceBase, getStyles8, void 0, { scope: "PersonaPresence" });

// node_modules/@fluentui/react/lib/components/Persona/PersonaInitialsColor.js
var COLOR_SWATCHES_LOOKUP = [
  PersonaInitialsColor.lightBlue,
  PersonaInitialsColor.blue,
  PersonaInitialsColor.darkBlue,
  PersonaInitialsColor.teal,
  PersonaInitialsColor.green,
  PersonaInitialsColor.darkGreen,
  PersonaInitialsColor.lightPink,
  PersonaInitialsColor.pink,
  PersonaInitialsColor.magenta,
  PersonaInitialsColor.purple,
  PersonaInitialsColor.orange,
  PersonaInitialsColor.lightRed,
  PersonaInitialsColor.darkRed,
  PersonaInitialsColor.violet,
  PersonaInitialsColor.gold,
  PersonaInitialsColor.burgundy,
  PersonaInitialsColor.warmGray,
  PersonaInitialsColor.cyan,
  PersonaInitialsColor.rust,
  PersonaInitialsColor.coolGray
];
var COLOR_SWATCHES_NUM_ENTRIES = COLOR_SWATCHES_LOOKUP.length;
function getInitialsColorFromName(displayName) {
  var color = PersonaInitialsColor.blue;
  if (!displayName) {
    return color;
  }
  var hashCode = 0;
  for (var iLen = displayName.length - 1; iLen >= 0; iLen--) {
    var ch = displayName.charCodeAt(iLen);
    var shift = iLen % 8;
    hashCode ^= (ch << shift) + (ch >> 8 - shift);
  }
  color = COLOR_SWATCHES_LOOKUP[hashCode % COLOR_SWATCHES_NUM_ENTRIES];
  return color;
}
function personaInitialsColorToHexCode(personaInitialsColor) {
  switch (personaInitialsColor) {
    case PersonaInitialsColor.lightBlue:
      return "#4F6BED";
    case PersonaInitialsColor.blue:
      return "#0078D4";
    case PersonaInitialsColor.darkBlue:
      return "#004E8C";
    case PersonaInitialsColor.teal:
      return "#038387";
    case PersonaInitialsColor.lightGreen:
    case PersonaInitialsColor.green:
      return "#498205";
    case PersonaInitialsColor.darkGreen:
      return "#0B6A0B";
    case PersonaInitialsColor.lightPink:
      return "#C239B3";
    case PersonaInitialsColor.pink:
      return "#E3008C";
    case PersonaInitialsColor.magenta:
      return "#881798";
    case PersonaInitialsColor.purple:
      return "#5C2E91";
    case PersonaInitialsColor.orange:
      return "#CA5010";
    case PersonaInitialsColor.red:
      return "#EE1111";
    case PersonaInitialsColor.lightRed:
      return "#D13438";
    case PersonaInitialsColor.darkRed:
      return "#A4262C";
    case PersonaInitialsColor.transparent:
      return "transparent";
    case PersonaInitialsColor.violet:
      return "#8764B8";
    case PersonaInitialsColor.gold:
      return "#986F0B";
    case PersonaInitialsColor.burgundy:
      return "#750B1C";
    case PersonaInitialsColor.warmGray:
      return "#7A7574";
    case PersonaInitialsColor.cyan:
      return "#005B70";
    case PersonaInitialsColor.rust:
      return "#8E562E";
    case PersonaInitialsColor.coolGray:
      return "#69797E";
    case PersonaInitialsColor.black:
      return "#1D1D1D";
    case PersonaInitialsColor.gray:
      return "#393939";
  }
}
function getPersonaInitialsColor(props) {
  var primaryText = props.primaryText, text = props.text;
  var initialsColor = props.initialsColor;
  var initialsColorCode;
  if (typeof initialsColor === "string") {
    initialsColorCode = initialsColor;
  } else {
    initialsColor = initialsColor !== void 0 ? initialsColor : getInitialsColorFromName(text || primaryText);
    initialsColorCode = personaInitialsColorToHexCode(initialsColor);
  }
  return initialsColorCode;
}

// node_modules/@fluentui/react/lib/components/Persona/PersonaCoin/PersonaCoin.base.js
var getClassNames9 = classNamesFunction({
  // There can be many PersonaCoin rendered with different sizes.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var getInitialsStyles = memoizeFunction(function(className, initialsColor, initialsTextColor, text, primaryText, showUnknownPersonaCoin) {
  return mergeStyles(className, !showUnknownPersonaCoin && {
    backgroundColor: getPersonaInitialsColor({ text, initialsColor, primaryText }),
    color: initialsTextColor
  });
});
var DEFAULT_PROPS3 = {
  size: PersonaSize.size48,
  presence: PersonaPresence.none,
  imageAlt: ""
};
function useDebugWarnings2(props) {
  if (true) {
    useWarnings({
      name: "PersonaCoin",
      props,
      deprecations: { primaryText: "text" }
    });
  }
}
function useImageLoadState(_a4) {
  var onPhotoLoadingStateChange = _a4.onPhotoLoadingStateChange, imageUrl = _a4.imageUrl;
  var _b = React36.useState(ImageLoadState.notLoaded), imageLoadState = _b[0], setImageLoadstate = _b[1];
  React36.useEffect(function() {
    setImageLoadstate(ImageLoadState.notLoaded);
  }, [imageUrl]);
  var onLoadingStateChange = function(loadState) {
    setImageLoadstate(loadState);
    onPhotoLoadingStateChange === null || onPhotoLoadingStateChange === void 0 ? void 0 : onPhotoLoadingStateChange(loadState);
  };
  return [imageLoadState, onLoadingStateChange];
}
var PersonaCoinBase = React36.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS3, propsWithoutDefaults);
  useDebugWarnings2(props);
  var _a4 = useImageLoadState(props), imageLoadState = _a4[0], onLoadingStateChange = _a4[1];
  var renderCoin = getCoinRenderer(onLoadingStateChange);
  var className = props.className, coinProps = props.coinProps, showUnknownPersonaCoin = props.showUnknownPersonaCoin, coinSize = props.coinSize, styles = props.styles, imageUrl = props.imageUrl, initialsColor = props.initialsColor, initialsTextColor = props.initialsTextColor, isOutOfOffice = props.isOutOfOffice, _b = props.onRenderCoin, onRenderCoin = _b === void 0 ? renderCoin : _b, _c = props.onRenderPersonaCoin, onRenderPersonaCoin = _c === void 0 ? onRenderCoin : _c, _d = props.onRenderInitials, onRenderInitials = _d === void 0 ? renderPersonaCoinInitials : _d, presence = props.presence, presenceTitle = props.presenceTitle, presenceColors = props.presenceColors, primaryText = props.primaryText, showInitialsUntilImageLoads = props.showInitialsUntilImageLoads, text = props.text, theme = props.theme, size = props.size;
  var divProps = getNativeProps(props, divProperties);
  var divCoinProps = getNativeProps(coinProps || {}, divProperties);
  var coinSizeStyle = coinSize ? { width: coinSize, height: coinSize } : void 0;
  var hideImage = showUnknownPersonaCoin;
  var personaPresenceProps = {
    coinSize,
    isOutOfOffice,
    presence,
    presenceTitle,
    presenceColors,
    size,
    theme
  };
  var classNames2 = getClassNames9(styles, {
    theme,
    className: coinProps && coinProps.className ? coinProps.className : className,
    size,
    coinSize,
    showUnknownPersonaCoin
  });
  var shouldRenderInitials = Boolean(imageLoadState !== ImageLoadState.loaded && (showInitialsUntilImageLoads && imageUrl || !imageUrl || imageLoadState === ImageLoadState.error || hideImage));
  return React36.createElement(
    "div",
    __assign({ role: "presentation" }, divProps, { className: classNames2.coin, ref: forwardedRef }),
    // Render PersonaCoin if size is not size8. size10 and tiny need to removed after a deprecation cleanup.
    // eslint-disable-next-line deprecation/deprecation
    size !== PersonaSize.size8 && size !== PersonaSize.size10 && size !== PersonaSize.tiny ? React36.createElement(
      "div",
      __assign({ role: "presentation" }, divCoinProps, { className: classNames2.imageArea, style: coinSizeStyle }),
      shouldRenderInitials && React36.createElement("div", { className: getInitialsStyles(classNames2.initials, initialsColor, initialsTextColor, text, primaryText, showUnknownPersonaCoin), style: coinSizeStyle, "aria-hidden": "true" }, onRenderInitials(props, renderPersonaCoinInitials)),
      !hideImage && onRenderPersonaCoin(props, renderCoin),
      React36.createElement(PersonaPresence2, __assign({}, personaPresenceProps))
    ) : (
      // Otherwise, render just PersonaPresence.
      props.presence ? React36.createElement(PersonaPresence2, __assign({}, personaPresenceProps)) : (
        // Just render Contact Icon if there isn't a Presence prop.
        React36.createElement(Icon, { iconName: "Contact", className: classNames2.size10WithoutPresenceIcon })
      )
    ),
    props.children
  );
});
PersonaCoinBase.displayName = "PersonaCoinBase";
var getCoinRenderer = function(onLoadingStateChange) {
  return function(_a4) {
    var coinSize = _a4.coinSize, styles = _a4.styles, imageUrl = _a4.imageUrl, imageAlt = _a4.imageAlt, imageShouldFadeIn = _a4.imageShouldFadeIn, imageShouldStartVisible = _a4.imageShouldStartVisible, theme = _a4.theme, showUnknownPersonaCoin = _a4.showUnknownPersonaCoin, _b = _a4.size, size = _b === void 0 ? DEFAULT_PROPS3.size : _b;
    if (!imageUrl) {
      return null;
    }
    var classNames2 = getClassNames9(styles, {
      theme,
      size,
      showUnknownPersonaCoin
    });
    var dimension = coinSize || sizeToPixels[size];
    return React36.createElement(Image, { className: classNames2.image, imageFit: ImageFit.cover, src: imageUrl, width: dimension, height: dimension, alt: imageAlt, shouldFadeIn: imageShouldFadeIn, shouldStartVisible: imageShouldStartVisible, onLoadingStateChange });
  };
};
var renderPersonaCoinInitials = function(_a4) {
  var imageInitials = _a4.imageInitials, allowPhoneInitials = _a4.allowPhoneInitials, showUnknownPersonaCoin = _a4.showUnknownPersonaCoin, text = _a4.text, primaryText = _a4.primaryText, theme = _a4.theme;
  if (showUnknownPersonaCoin) {
    return React36.createElement(Icon, { iconName: "Help" });
  }
  var isRTL = getRTL(theme);
  imageInitials = imageInitials || getInitials(text || primaryText || "", isRTL, allowPhoneInitials);
  return imageInitials !== "" ? React36.createElement("span", null, imageInitials) : React36.createElement(Icon, { iconName: "Contact" });
};

// node_modules/@fluentui/react/lib/components/Persona/PersonaCoin/PersonaCoin.styles.js
var GlobalClassNames7 = {
  coin: "ms-Persona-coin",
  imageArea: "ms-Persona-imageArea",
  image: "ms-Persona-image",
  initials: "ms-Persona-initials",
  size8: "ms-Persona--size8",
  size10: "ms-Persona--size10",
  size16: "ms-Persona--size16",
  size24: "ms-Persona--size24",
  size28: "ms-Persona--size28",
  size32: "ms-Persona--size32",
  size40: "ms-Persona--size40",
  size48: "ms-Persona--size48",
  size56: "ms-Persona--size56",
  size72: "ms-Persona--size72",
  size100: "ms-Persona--size100",
  size120: "ms-Persona--size120"
};
var getStyles9 = function(props) {
  var _a4;
  var className = props.className, theme = props.theme, coinSize = props.coinSize;
  var palette = theme.palette, fonts = theme.fonts;
  var size = sizeBoolean(props.size);
  var classNames2 = getGlobalClassNames(GlobalClassNames7, theme);
  var unknownPersonaBackgroundColor = "rgb(234, 234, 234)";
  var unknownPersonaFontColor = "rgb(168, 0, 0)";
  var dimension = coinSize || props.size && sizeToPixels[props.size] || 48;
  return {
    coin: [
      classNames2.coin,
      fonts.medium,
      size.isSize8 && classNames2.size8,
      size.isSize10 && classNames2.size10,
      size.isSize16 && classNames2.size16,
      size.isSize24 && classNames2.size24,
      size.isSize28 && classNames2.size28,
      size.isSize32 && classNames2.size32,
      size.isSize40 && classNames2.size40,
      size.isSize48 && classNames2.size48,
      size.isSize56 && classNames2.size56,
      size.isSize72 && classNames2.size72,
      size.isSize100 && classNames2.size100,
      size.isSize120 && classNames2.size120,
      className
    ],
    size10WithoutPresenceIcon: {
      fontSize: fonts.xSmall.fontSize,
      position: "absolute",
      top: "5px",
      right: "auto",
      left: 0
    },
    imageArea: [
      classNames2.imageArea,
      {
        position: "relative",
        textAlign: "center",
        flex: "0 0 auto",
        height: dimension,
        width: dimension
      },
      dimension <= 10 && {
        overflow: "visible",
        background: "transparent",
        height: 0,
        width: 0
      }
    ],
    image: [
      classNames2.image,
      {
        marginRight: "10px",
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        border: 0,
        borderRadius: "50%",
        perspective: "1px"
      },
      dimension <= 10 && {
        overflow: "visible",
        background: "transparent",
        height: 0,
        width: 0
      },
      dimension > 10 && {
        height: dimension,
        width: dimension
      }
    ],
    initials: [
      classNames2.initials,
      {
        borderRadius: "50%",
        color: props.showUnknownPersonaCoin ? unknownPersonaFontColor : palette.white,
        fontSize: fonts.large.fontSize,
        fontWeight: FontWeights.semibold,
        // copying the logic for the dimensions; defaulted to 46 for size48
        lineHeight: dimension === 48 ? 46 : dimension,
        height: dimension,
        selectors: (_a4 = {}, _a4[HighContrastSelector] = __assign(__assign({ border: "1px solid WindowText" }, getHighContrastNoAdjustStyle()), { color: "WindowText", boxSizing: "border-box", backgroundColor: "Window !important" }), _a4.i = {
          fontWeight: FontWeights.semibold
        }, _a4)
      },
      props.showUnknownPersonaCoin && {
        backgroundColor: unknownPersonaBackgroundColor
      },
      dimension < 32 && {
        fontSize: fonts.xSmall.fontSize
      },
      dimension >= 32 && dimension < 40 && {
        fontSize: fonts.medium.fontSize
      },
      dimension >= 40 && dimension < 56 && {
        fontSize: fonts.mediumPlus.fontSize
      },
      dimension >= 56 && dimension < 72 && {
        fontSize: fonts.xLarge.fontSize
      },
      dimension >= 72 && dimension < 100 && {
        fontSize: fonts.xxLarge.fontSize
      },
      dimension >= 100 && {
        fontSize: fonts.superLarge.fontSize
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Persona/PersonaCoin/PersonaCoin.js
var PersonaCoin = styled(PersonaCoinBase, getStyles9, void 0, {
  scope: "PersonaCoin"
});

// node_modules/@fluentui/react/lib/components/Persona/Persona.base.js
var getClassNames10 = classNamesFunction();
var DEFAULT_PROPS4 = {
  size: PersonaSize.size48,
  presence: PersonaPresence.none,
  imageAlt: "",
  showOverflowTooltip: true
};
function useDebugWarnings3(props) {
  if (true) {
    useWarnings({
      name: "Persona",
      props,
      deprecations: { primaryText: "text" }
    });
  }
}
var PersonaBase = React37.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS4, propsWithoutDefaults);
  useDebugWarnings3(props);
  var rootRef = React37.useRef(null);
  var mergedRootRef = useMergedRefs(forwardedRef, rootRef);
  var getText = function() {
    return props.text || props.primaryText || "";
  };
  var renderElement = function(elementClassNames, renderFunction, defaultRenderFunction) {
    var content = renderFunction && renderFunction(props, defaultRenderFunction);
    return content ? React37.createElement("div", { dir: "auto", className: elementClassNames }, content) : void 0;
  };
  var onRenderText = function(text, tooltip) {
    if (tooltip === void 0) {
      tooltip = true;
    }
    return text ? tooltip ? function() {
      return React37.createElement(TooltipHost, { content: text, overflowMode: TooltipOverflowMode.Parent, directionalHint: DirectionalHint.topLeftEdge }, text);
    } : function() {
      return React37.createElement(React37.Fragment, null, text);
    } : void 0;
  };
  var onInternalRenderPersonaCoin = function(providedCoinProps) {
    return React37.createElement(PersonaCoin, __assign({}, providedCoinProps));
  };
  var onInternalRenderPrimaryText = onRenderText(getText(), props.showOverflowTooltip);
  var onInternalRenderSecondaryText = onRenderText(props.secondaryText, props.showOverflowTooltip);
  var onInternalRenderTertiaryText = onRenderText(props.tertiaryText, props.showOverflowTooltip);
  var onInternalRenderOptionalText = onRenderText(props.optionalText, props.showOverflowTooltip);
  var hidePersonaDetails = props.hidePersonaDetails, _a4 = props.onRenderOptionalText, onRenderOptionalText = _a4 === void 0 ? onInternalRenderOptionalText : _a4, _b = props.onRenderPrimaryText, onRenderPrimaryText = _b === void 0 ? onInternalRenderPrimaryText : _b, _c = props.onRenderSecondaryText, onRenderSecondaryText = _c === void 0 ? onInternalRenderSecondaryText : _c, _d = props.onRenderTertiaryText, onRenderTertiaryText = _d === void 0 ? onInternalRenderTertiaryText : _d, _e = props.onRenderPersonaCoin, onRenderPersonaCoin = _e === void 0 ? onInternalRenderPersonaCoin : _e;
  var size = props.size;
  var allowPhoneInitials = props.allowPhoneInitials, className = props.className, coinProps = props.coinProps, showUnknownPersonaCoin = props.showUnknownPersonaCoin, coinSize = props.coinSize, styles = props.styles, imageAlt = props.imageAlt, imageInitials = props.imageInitials, imageShouldFadeIn = props.imageShouldFadeIn, imageShouldStartVisible = props.imageShouldStartVisible, imageUrl = props.imageUrl, initialsColor = props.initialsColor, initialsTextColor = props.initialsTextColor, isOutOfOffice = props.isOutOfOffice, onPhotoLoadingStateChange = props.onPhotoLoadingStateChange, onRenderCoin = props.onRenderCoin, onRenderInitials = props.onRenderInitials, presence = props.presence, presenceTitle = props.presenceTitle, presenceColors = props.presenceColors, showInitialsUntilImageLoads = props.showInitialsUntilImageLoads, showSecondaryText = props.showSecondaryText, theme = props.theme;
  var personaCoinProps = __assign({ allowPhoneInitials, showUnknownPersonaCoin, coinSize, imageAlt, imageInitials, imageShouldFadeIn, imageShouldStartVisible, imageUrl, initialsColor, initialsTextColor, onPhotoLoadingStateChange, onRenderCoin, onRenderInitials, presence, presenceTitle, showInitialsUntilImageLoads, size, text: getText(), isOutOfOffice, presenceColors }, coinProps);
  var classNames2 = getClassNames10(styles, {
    theme,
    className,
    showSecondaryText,
    presence,
    size
  });
  var divProps = getNativeProps(props, divProperties);
  var personaDetails = React37.createElement(
    "div",
    { className: classNames2.details },
    renderElement(classNames2.primaryText, onRenderPrimaryText, onInternalRenderPrimaryText),
    renderElement(classNames2.secondaryText, onRenderSecondaryText, onInternalRenderSecondaryText),
    renderElement(classNames2.tertiaryText, onRenderTertiaryText, onInternalRenderTertiaryText),
    renderElement(classNames2.optionalText, onRenderOptionalText, onInternalRenderOptionalText),
    props.children
  );
  return React37.createElement(
    "div",
    __assign({}, divProps, { ref: mergedRootRef, className: classNames2.root, style: coinSize ? { height: coinSize, minWidth: coinSize } : void 0 }),
    onRenderPersonaCoin(personaCoinProps, onRenderPersonaCoin),
    /* eslint-disable deprecation/deprecation */
    (!hidePersonaDetails || size === PersonaSize.size8 || size === PersonaSize.size10 || size === PersonaSize.tiny) && personaDetails
    /* eslint-enable deprecation/deprecation */
  );
});
PersonaBase.displayName = "PersonaBase";

// node_modules/@fluentui/react/lib/components/Persona/Persona.styles.js
var GlobalClassNames8 = {
  root: "ms-Persona",
  size8: "ms-Persona--size8",
  size10: "ms-Persona--size10",
  size16: "ms-Persona--size16",
  size24: "ms-Persona--size24",
  size28: "ms-Persona--size28",
  size32: "ms-Persona--size32",
  size40: "ms-Persona--size40",
  size48: "ms-Persona--size48",
  size56: "ms-Persona--size56",
  size72: "ms-Persona--size72",
  size100: "ms-Persona--size100",
  size120: "ms-Persona--size120",
  available: "ms-Persona--online",
  away: "ms-Persona--away",
  blocked: "ms-Persona--blocked",
  busy: "ms-Persona--busy",
  doNotDisturb: "ms-Persona--donotdisturb",
  offline: "ms-Persona--offline",
  details: "ms-Persona-details",
  primaryText: "ms-Persona-primaryText",
  secondaryText: "ms-Persona-secondaryText",
  tertiaryText: "ms-Persona-tertiaryText",
  optionalText: "ms-Persona-optionalText",
  textContent: "ms-Persona-textContent"
};
var getStyles10 = function(props) {
  var className = props.className, showSecondaryText = props.showSecondaryText, theme = props.theme;
  var semanticColors = theme.semanticColors, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames8, theme);
  var size = sizeBoolean(props.size);
  var presence = presenceBoolean(props.presence);
  var showSecondaryTextDefaultHeight = "16px";
  var sharedTextStyles = {
    color: semanticColors.bodySubtext,
    fontWeight: FontWeights.regular,
    fontSize: fonts.small.fontSize
  };
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      normalize,
      {
        color: semanticColors.bodyText,
        position: "relative",
        height: personaSize.size48,
        minWidth: personaSize.size48,
        display: "flex",
        alignItems: "center",
        selectors: {
          ".contextualHost": {
            display: "none"
          }
        }
      },
      size.isSize8 && [
        classNames2.size8,
        {
          height: personaSize.size8,
          minWidth: personaSize.size8
        }
      ],
      // TODO: Deprecated size and needs to be removed in a future major release.
      size.isSize10 && [
        classNames2.size10,
        {
          height: personaSize.size10,
          minWidth: personaSize.size10
        }
      ],
      // TODO: Deprecated size and needs to be removed in a future major release.
      size.isSize16 && [
        classNames2.size16,
        {
          height: personaSize.size16,
          minWidth: personaSize.size16
        }
      ],
      size.isSize24 && [
        classNames2.size24,
        {
          height: personaSize.size24,
          minWidth: personaSize.size24
        }
      ],
      size.isSize24 && showSecondaryText && {
        height: "36px"
      },
      // TODO: Deprecated size and needs to be removed in a future major release.
      size.isSize28 && [
        classNames2.size28,
        {
          height: personaSize.size28,
          minWidth: personaSize.size28
        }
      ],
      size.isSize28 && showSecondaryText && {
        height: "32px"
      },
      size.isSize32 && [
        classNames2.size32,
        {
          height: personaSize.size32,
          minWidth: personaSize.size32
        }
      ],
      size.isSize40 && [
        classNames2.size40,
        {
          height: personaSize.size40,
          minWidth: personaSize.size40
        }
      ],
      size.isSize48 && classNames2.size48,
      size.isSize56 && [
        classNames2.size56,
        {
          height: personaSize.size56,
          minWidth: personaSize.size56
        }
      ],
      size.isSize72 && [
        classNames2.size72,
        {
          height: personaSize.size72,
          minWidth: personaSize.size72
        }
      ],
      size.isSize100 && [
        classNames2.size100,
        {
          height: personaSize.size100,
          minWidth: personaSize.size100
        }
      ],
      size.isSize120 && [
        classNames2.size120,
        {
          height: personaSize.size120,
          minWidth: personaSize.size120
        }
      ],
      /**
       * Modifiers: presence
       */
      presence.isAvailable && classNames2.available,
      presence.isAway && classNames2.away,
      presence.isBlocked && classNames2.blocked,
      presence.isBusy && classNames2.busy,
      presence.isDoNotDisturb && classNames2.doNotDisturb,
      presence.isOffline && classNames2.offline,
      className
    ],
    details: [
      classNames2.details,
      {
        padding: "0 24px 0 16px",
        minWidth: 0,
        width: "100%",
        textAlign: "left",
        display: "flex",
        flexDirection: "column",
        justifyContent: "space-around"
      },
      (size.isSize8 || size.isSize10) && {
        paddingLeft: 17
        // increased padding because we don't render a coin at this size
      },
      (size.isSize24 || size.isSize28 || size.isSize32) && {
        padding: "0 8px"
      },
      (size.isSize40 || size.isSize48) && {
        padding: "0 12px"
      }
    ],
    primaryText: [
      classNames2.primaryText,
      noWrap,
      {
        color: semanticColors.bodyText,
        fontWeight: FontWeights.regular,
        fontSize: fonts.medium.fontSize,
        selectors: {
          ":hover": {
            color: semanticColors.inputTextHovered
          }
        }
      },
      showSecondaryText && {
        height: showSecondaryTextDefaultHeight,
        lineHeight: showSecondaryTextDefaultHeight,
        overflowX: "hidden"
      },
      (size.isSize8 || size.isSize10) && {
        fontSize: fonts.small.fontSize,
        lineHeight: personaSize.size8
      },
      size.isSize16 && {
        lineHeight: personaSize.size28
      },
      (size.isSize24 || size.isSize28 || size.isSize32 || size.isSize40 || size.isSize48) && showSecondaryText && {
        height: 18
      },
      (size.isSize56 || size.isSize72 || size.isSize100 || size.isSize120) && {
        fontSize: fonts.xLarge.fontSize
      },
      (size.isSize56 || size.isSize72 || size.isSize100 || size.isSize120) && showSecondaryText && {
        height: 22
      }
    ],
    secondaryText: [
      classNames2.secondaryText,
      noWrap,
      sharedTextStyles,
      (size.isSize8 || size.isSize10 || size.isSize16 || size.isSize24 || size.isSize28 || size.isSize32) && {
        display: "none"
      },
      showSecondaryText && {
        display: "block",
        height: showSecondaryTextDefaultHeight,
        lineHeight: showSecondaryTextDefaultHeight,
        overflowX: "hidden"
      },
      size.isSize24 && showSecondaryText && {
        height: 18
      },
      (size.isSize56 || size.isSize72 || size.isSize100 || size.isSize120) && {
        fontSize: fonts.medium.fontSize
      },
      (size.isSize56 || size.isSize72 || size.isSize100 || size.isSize120) && showSecondaryText && {
        height: 18
      }
    ],
    tertiaryText: [
      classNames2.tertiaryText,
      noWrap,
      sharedTextStyles,
      {
        display: "none",
        fontSize: fonts.medium.fontSize
      },
      (size.isSize72 || size.isSize100 || size.isSize120) && {
        display: "block"
      }
    ],
    optionalText: [
      classNames2.optionalText,
      noWrap,
      sharedTextStyles,
      {
        display: "none",
        fontSize: fonts.medium.fontSize
      },
      (size.isSize100 || size.isSize120) && {
        display: "block"
      }
    ],
    textContent: [classNames2.textContent, noWrap]
  };
};

// node_modules/@fluentui/react/lib/components/Persona/Persona.js
var Persona = styled(PersonaBase, getStyles10, void 0, {
  scope: "Persona"
});

export {
  DirectionalHint,
  RectangleEdge,
  Position,
  positionElement,
  positionCallout,
  positionCard,
  getMaxHeight,
  getOppositeEdge,
  getBoundsFromTargetWindow,
  useAsync,
  useConst,
  useBoolean,
  useControllableValue,
  useId,
  useMergedRefs,
  useOnEvent,
  usePrevious,
  useRefEffect,
  useSetTimeout,
  WindowContext,
  useWindow,
  useDocument,
  WindowProvider,
  useTarget,
  useUnmount,
  useWarnings,
  Popup,
  CalloutContentBase,
  CalloutContent,
  FabricBase,
  Fabric,
  registerLayer,
  unregisterLayer,
  getLayerCount,
  getLayerHost,
  registerLayerHost,
  unregisterLayerHost,
  createDefaultLayerHost,
  cleanupDefaultLayerHost,
  notifyHostChanged,
  setDefaultTarget,
  getDefaultTarget,
  LayerBase,
  getStyles3 as getStyles,
  Layer,
  LayerHost,
  Callout,
  FocusTrapZone,
  FocusTrapCallout,
  TooltipBase,
  Tooltip,
  TooltipDelay,
  TooltipOverflowMode,
  TooltipHostBase,
  TooltipHost,
  IconType,
  ImageFit,
  ImageCoverStyle,
  ImageLoadState,
  ImageBase,
  Image,
  getIconContent,
  FontIcon,
  getFontIcon,
  IconBase,
  Icon,
  ImageIcon,
  PersonaSize,
  PersonaPresence,
  PersonaInitialsColor,
  personaSize,
  personaPresenceSize,
  sizeBoolean,
  sizeToPixels,
  presenceBoolean,
  getPersonaInitialsColor,
  PersonaCoinBase,
  PersonaCoin,
  PersonaBase,
  Persona
};
//# sourceMappingURL=chunk-JJ24FNU3.js.map
