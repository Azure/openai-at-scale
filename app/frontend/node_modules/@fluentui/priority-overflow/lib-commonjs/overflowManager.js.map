{"version":3,"sources":["../lib/overflowManager.js"],"sourcesContent":["import { debounce } from './debounce';\nimport { createPriorityQueue } from './priorityQueue';\n/**\n * @internal\n * @returns overflow manager instance\n */\nexport function createOverflowManager() {\n  let container;\n  let overflowMenu;\n  // Set as true when resize observer is observing\n  let observing = false;\n  // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n  let forceDispatch = false;\n  const options = {\n    padding: 10,\n    overflowAxis: 'horizontal',\n    overflowDirection: 'end',\n    minimumVisible: 0,\n    onUpdateItemVisibility: () => undefined,\n    onUpdateOverflow: () => undefined\n  };\n  const overflowItems = {};\n  const overflowGroups = {};\n  const resizeObserver = new ResizeObserver(entries => {\n    if (!entries[0] || !container) {\n      return;\n    }\n    update();\n  });\n  const invisibleItemQueue = createPriorityQueue((a, b) => {\n    const itemA = overflowItems[a];\n    const itemB = overflowItems[b];\n    // Higher priority at the top of the queue\n    const priority = itemB.priority - itemA.priority;\n    if (priority !== 0) {\n      return priority;\n    }\n    const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n    // equal priority, use DOM order\n    // eslint-disable-next-line no-bitwise\n    return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n  });\n  const visibleItemQueue = createPriorityQueue((a, b) => {\n    const itemA = overflowItems[a];\n    const itemB = overflowItems[b];\n    // Lower priority at the top of the queue\n    const priority = itemA.priority - itemB.priority;\n    if (priority !== 0) {\n      return priority;\n    }\n    const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_PRECEDING : Node.DOCUMENT_POSITION_FOLLOWING;\n    // equal priority, use DOM order\n    // eslint-disable-next-line no-bitwise\n    return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n  });\n  const getOffsetSize = el => {\n    return options.overflowAxis === 'horizontal' ? el.offsetWidth : el.offsetHeight;\n  };\n  const makeItemVisible = () => {\n    const nextVisible = invisibleItemQueue.dequeue();\n    visibleItemQueue.enqueue(nextVisible);\n    const item = overflowItems[nextVisible];\n    options.onUpdateItemVisibility({\n      item,\n      visible: true\n    });\n    if (item.groupId) {\n      overflowGroups[item.groupId].invisibleItemIds.delete(item.id);\n      overflowGroups[item.groupId].visibleItemIds.add(item.id);\n    }\n    return getOffsetSize(item.element);\n  };\n  const makeItemInvisible = () => {\n    const nextInvisible = visibleItemQueue.dequeue();\n    invisibleItemQueue.enqueue(nextInvisible);\n    const item = overflowItems[nextInvisible];\n    const width = getOffsetSize(item.element);\n    options.onUpdateItemVisibility({\n      item,\n      visible: false\n    });\n    if (item.groupId) {\n      overflowGroups[item.groupId].visibleItemIds.delete(item.id);\n      overflowGroups[item.groupId].invisibleItemIds.add(item.id);\n    }\n    return width;\n  };\n  const dispatchOverflowUpdate = () => {\n    const visibleItemIds = visibleItemQueue.all();\n    const invisibleItemIds = invisibleItemQueue.all();\n    const visibleItems = visibleItemIds.map(itemId => overflowItems[itemId]);\n    const invisibleItems = invisibleItemIds.map(itemId => overflowItems[itemId]);\n    const groupVisibility = {};\n    Object.entries(overflowGroups).forEach(([groupId, groupState]) => {\n      if (groupState.invisibleItemIds.size && groupState.visibleItemIds.size) {\n        groupVisibility[groupId] = 'overflow';\n      } else if (groupState.visibleItemIds.size === 0) {\n        groupVisibility[groupId] = 'hidden';\n      } else {\n        groupVisibility[groupId] = 'visible';\n      }\n    });\n    options.onUpdateOverflow({\n      visibleItems,\n      invisibleItems,\n      groupVisibility\n    });\n  };\n  const processOverflowItems = () => {\n    if (!container) {\n      return false;\n    }\n    const availableSize = getOffsetSize(container) - options.padding;\n    const overflowMenuOffset = overflowMenu ? getOffsetSize(overflowMenu) : 0;\n    // Snapshot of the visible/invisible state to compare for updates\n    const visibleTop = visibleItemQueue.peek();\n    const invisibleTop = invisibleItemQueue.peek();\n    const visibleItemIds = visibleItemQueue.all();\n    let currentWidth = visibleItemIds.reduce((sum, visibleItemId) => {\n      const child = overflowItems[visibleItemId].element;\n      return sum + getOffsetSize(child);\n    }, 0);\n    // Add items until available width is filled - can result in overflow\n    while (currentWidth < availableSize && invisibleItemQueue.size() > 0) {\n      currentWidth += makeItemVisible();\n    }\n    // Remove items until there's no more overflow\n    while (currentWidth > availableSize && visibleItemQueue.size() > 0) {\n      if (visibleItemQueue.size() <= options.minimumVisible) {\n        break;\n      }\n      currentWidth -= makeItemInvisible();\n    }\n    // make sure the overflow menu can fit\n    if (visibleItemQueue.size() > options.minimumVisible && invisibleItemQueue.size() > 0 && currentWidth + overflowMenuOffset > availableSize) {\n      makeItemInvisible();\n    }\n    // only update when the state of visible/invisible items has changed\n    if (visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop) {\n      return true;\n    }\n    return false;\n  };\n  const forceUpdate = () => {\n    if (processOverflowItems() || forceDispatch) {\n      forceDispatch = false;\n      dispatchOverflowUpdate();\n    }\n  };\n  const update = debounce(forceUpdate);\n  const observe = (observedContainer, userOptions) => {\n    Object.assign(options, userOptions);\n    observing = true;\n    Object.values(overflowItems).forEach(item => visibleItemQueue.enqueue(item.id));\n    container = observedContainer;\n    resizeObserver.observe(container);\n  };\n  const disconnect = () => {\n    observing = false;\n    resizeObserver.disconnect();\n  };\n  const addItem = item => {\n    if (overflowItems[item.id]) {\n      return;\n    }\n    overflowItems[item.id] = item;\n    // some options can affect priority which are only set on `observe`\n    if (observing) {\n      // Updates to elements might not change the queue tops\n      // i.e. new element is enqueued but the top of the queue stays the same\n      // force a dispatch on the next batched update\n      forceDispatch = true;\n      visibleItemQueue.enqueue(item.id);\n    }\n    if (item.groupId) {\n      if (!overflowGroups[item.groupId]) {\n        overflowGroups[item.groupId] = {\n          visibleItemIds: new Set(),\n          invisibleItemIds: new Set()\n        };\n      }\n      overflowGroups[item.groupId].visibleItemIds.add(item.id);\n    }\n    update();\n  };\n  const addOverflowMenu = el => {\n    overflowMenu = el;\n  };\n  const removeOverflowMenu = () => {\n    overflowMenu = undefined;\n  };\n  const removeItem = itemId => {\n    if (!overflowItems[itemId]) {\n      return;\n    }\n    const item = overflowItems[itemId];\n    visibleItemQueue.remove(itemId);\n    invisibleItemQueue.remove(itemId);\n    if (item.groupId) {\n      overflowGroups[item.groupId].visibleItemIds.delete(item.id);\n      overflowGroups[item.groupId].invisibleItemIds.delete(item.id);\n    }\n    delete overflowItems[itemId];\n    update();\n  };\n  return {\n    addItem,\n    disconnect,\n    forceUpdate,\n    observe,\n    removeItem,\n    update,\n    addOverflowMenu,\n    removeOverflowMenu\n  };\n}\n//# sourceMappingURL=overflowManager.js.map"],"names":["createOverflowManager","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowGroups","resizeObserver","ResizeObserver","entries","update","invisibleItemQueue","createPriorityQueue","a","b","itemA","itemB","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","visibleItemQueue","getOffsetSize","el","offsetWidth","offsetHeight","makeItemVisible","nextVisible","dequeue","enqueue","item","visible","groupId","invisibleItemIds","delete","id","visibleItemIds","add","makeItemInvisible","nextInvisible","width","dispatchOverflowUpdate","all","visibleItems","map","itemId","invisibleItems","groupVisibility","Object","forEach","groupState","size","processOverflowItems","availableSize","overflowMenuOffset","visibleTop","peek","invisibleTop","currentWidth","reduce","sum","visibleItemId","child","forceUpdate","debounce","observe","observedContainer","userOptions","assign","values","disconnect","addItem","Set","addOverflowMenu","removeOverflowMenu","removeItem","remove"],"mappings":"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"}