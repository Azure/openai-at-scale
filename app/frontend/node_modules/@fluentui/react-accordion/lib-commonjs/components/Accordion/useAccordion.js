"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useAccordion_unstable", {
    enumerable: true,
    get: ()=>useAccordion_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactTabster = require("@fluentui/react-tabster");
const useAccordion_unstable = (props, ref)=>{
    const { openItems: controlledOpenItems , defaultOpenItems , multiple =false , collapsible =false , onToggle , navigation  } = props;
    const [openItems, setOpenItems] = (0, _reactUtilities.useControllableState)({
        state: _react.useMemo(()=>normalizeValues(controlledOpenItems), [
            controlledOpenItems
        ]),
        defaultState: ()=>initializeUncontrolledOpenItems({
                defaultOpenItems,
                multiple
            }),
        initialState: []
    });
    const arrowNavigationProps = (0, _reactTabster.useArrowNavigationGroup)({
        circular: navigation === 'circular',
        tabbable: true
    });
    const requestToggle = (0, _reactUtilities.useEventCallback)((event, data)=>{
        onToggle === null || onToggle === void 0 ? void 0 : onToggle(event, data);
        setOpenItems((previousOpenItems)=>updateOpenItems(data.value, previousOpenItems, multiple, collapsible));
    });
    return {
        collapsible,
        navigation,
        openItems,
        requestToggle,
        components: {
            root: 'div'
        },
        root: (0, _reactUtilities.getNativeElementProps)('div', {
            ...props,
            ...navigation ? arrowNavigationProps : {},
            ref
        })
    };
};
/**
 * Initial value for the uncontrolled case of the list of open indexes
 */ function initializeUncontrolledOpenItems({ defaultOpenItems , multiple  }) {
    if (defaultOpenItems !== undefined) {
        if (Array.isArray(defaultOpenItems)) {
            return multiple ? defaultOpenItems : [
                defaultOpenItems[0]
            ];
        }
        return [
            defaultOpenItems
        ];
    }
    return [];
}
/**
 * Updates the list of open indexes based on an index that changes
 * @param value - the index that will change
 * @param previousOpenItems - list of current open indexes
 * @param multiple - if Accordion support multiple Panels opened at the same time
 * @param collapsible - if Accordion support multiple Panels closed at the same time
 */ function updateOpenItems(value, previousOpenItems, multiple, collapsible) {
    if (multiple) {
        if (previousOpenItems.includes(value)) {
            if (previousOpenItems.length > 1 || collapsible) {
                return previousOpenItems.filter((i)=>i !== value);
            }
        } else {
            return [
                ...previousOpenItems,
                value
            ].sort();
        }
    } else {
        return previousOpenItems[0] === value && collapsible ? [] : [
            value
        ];
    }
    return previousOpenItems;
}
/**
 * Normalizes Accordion index into an array of indexes
 */ function normalizeValues(index) {
    if (index === undefined) {
        return undefined;
    }
    return Array.isArray(index) ? index : [
        index
    ];
} //# sourceMappingURL=useAccordion.js.map

//# sourceMappingURL=useAccordion.js.map