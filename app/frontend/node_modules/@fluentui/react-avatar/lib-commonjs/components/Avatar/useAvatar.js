"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_STRINGS: ()=>DEFAULT_STRINGS,
    useAvatar_unstable: ()=>useAvatar_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _index = require("../../utils/index");
const _reactIcons = require("@fluentui/react-icons");
const _reactBadge = require("@fluentui/react-badge");
const _reactSharedContexts = require("@fluentui/react-shared-contexts");
const _avatarContext = require("../../contexts/AvatarContext");
const DEFAULT_STRINGS = {
    active: 'active',
    inactive: 'inactive'
};
const useAvatar_unstable = (props, ref)=>{
    const { dir  } = (0, _reactSharedContexts.useFluent_unstable)();
    const { size: contextSize  } = (0, _avatarContext.useAvatarContext)();
    const { name , size =contextSize !== null && contextSize !== void 0 ? contextSize : 32 , shape ='circular' , active ='unset' , activeAppearance ='ring' , idForColor  } = props;
    let { color ='neutral'  } = props;
    // Resolve 'colorful' to a specific color name
    if (color === 'colorful') {
        var _ref;
        color = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name) !== null && _ref !== void 0 ? _ref : '') % avatarColors.length];
    }
    const baseId = (0, _reactUtilities.useId)('avatar-');
    const root = (0, _reactUtilities.getNativeElementProps)('span', {
        role: 'img',
        id: baseId,
        // aria-label and/or aria-labelledby are resolved below
        ...props,
        ref
    }, /* excludedPropNames: */ [
        'name'
    ]);
    const [imageHidden, setImageHidden] = _react.useState(undefined);
    const image = (0, _reactUtilities.resolveShorthand)(props.image, {
        defaultProps: {
            alt: '',
            role: 'presentation',
            'aria-hidden': true,
            hidden: imageHidden
        }
    });
    // Hide the image if it fails to load and restore it on a successful load
    if (image) {
        image.onError = (0, _reactUtilities.mergeCallbacks)(image.onError, ()=>setImageHidden(true));
        image.onLoad = (0, _reactUtilities.mergeCallbacks)(image.onLoad, ()=>setImageHidden(undefined));
    }
    // Resolve the initials slot, defaulted to getInitials.
    let initials = (0, _reactUtilities.resolveShorthand)(props.initials, {
        required: true,
        defaultProps: {
            children: (0, _index.getInitials)(name, dir === 'rtl', {
                firstInitialOnly: size <= 16
            }),
            id: baseId + '__initials'
        }
    });
    // Don't render the initials slot if it's empty
    if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
        initials = undefined;
    }
    // Render the icon slot *only if* there aren't any initials or image to display
    let icon = undefined;
    if (!initials && (!image || imageHidden)) {
        icon = (0, _reactUtilities.resolveShorthand)(props.icon, {
            required: true,
            defaultProps: {
                children: /*#__PURE__*/ _react.createElement(_reactIcons.PersonRegular, null),
                'aria-hidden': true
            }
        });
    }
    const badge = (0, _reactUtilities.resolveShorthand)(props.badge, {
        defaultProps: {
            size: getBadgeSize(size),
            id: baseId + '__badge'
        }
    });
    let activeAriaLabelElement;
    // Resolve aria-label and/or aria-labelledby if not provided by the user
    if (!root['aria-label'] && !root['aria-labelledby']) {
        if (name) {
            root['aria-label'] = name;
            // Include the badge in labelledby if it exists
            if (badge) {
                root['aria-labelledby'] = root.id + ' ' + badge.id;
            }
        } else if (initials) {
            // root's aria-label should be the name, but fall back to being labelledby the initials if name is missing
            root['aria-labelledby'] = initials.id + (badge ? ' ' + badge.id : '');
        }
        // Add the active state to the aria label
        if (active === 'active' || active === 'inactive') {
            const activeText = DEFAULT_STRINGS[active];
            if (root['aria-labelledby']) {
                // If using aria-labelledby, render a hidden span and append it to the labelledby
                const activeId = baseId + '__active';
                root['aria-labelledby'] += ' ' + activeId;
                activeAriaLabelElement = /*#__PURE__*/ _react.createElement("span", {
                    hidden: true,
                    id: activeId
                }, activeText);
            } else if (root['aria-label']) {
                // Otherwise, just append it to the aria-label
                root['aria-label'] += ' ' + activeText;
            }
        }
    }
    return {
        size,
        shape,
        active,
        activeAppearance,
        activeAriaLabelElement,
        color,
        components: {
            root: 'span',
            initials: 'span',
            icon: 'span',
            image: 'img',
            badge: _reactBadge.PresenceBadge
        },
        root,
        initials,
        icon,
        image,
        badge
    };
};
const getBadgeSize = (size)=>{
    if (size >= 96) {
        return 'extra-large';
    } else if (size >= 64) {
        return 'large';
    } else if (size >= 56) {
        return 'medium';
    } else if (size >= 40) {
        return 'small';
    } else if (size >= 28) {
        return 'extra-small';
    } else {
        return 'tiny';
    }
};
const avatarColors = [
    'dark-red',
    'cranberry',
    'red',
    'pumpkin',
    'peach',
    'marigold',
    'gold',
    'brass',
    'brown',
    'forest',
    'seafoam',
    'dark-green',
    'light-teal',
    'teal',
    'steel',
    'blue',
    'royal-blue',
    'cornflower',
    'navy',
    'lavender',
    'purple',
    'grape',
    'lilac',
    'pink',
    'magenta',
    'plum',
    'beige',
    'mink',
    'platinum',
    'anchor'
];
const getHashCode = (str)=>{
    let hashCode = 0;
    for(let len = str.length - 1; len >= 0; len--){
        const ch = str.charCodeAt(len);
        const shift = len % 8;
        hashCode ^= (ch << shift) + (ch >> 8 - shift); // eslint-disable-line no-bitwise
    }
    return hashCode;
}; //# sourceMappingURL=useAvatar.js.map

//# sourceMappingURL=useAvatar.js.map