"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useCardSelectable", {
    enumerable: true,
    get: ()=>useCardSelectable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _keyboardKeys = require("@fluentui/keyboard-keys");
const _reactTabster = require("@fluentui/react-tabster");
const useCardSelectable = (props, { referenceLabel , referenceId  }, cardRef)=>{
    const { checkbox ={} , selected , defaultSelected , onSelectionChange , floatingAction , onClick , onKeyDown  } = props;
    const { findAllFocusable  } = (0, _reactTabster.useFocusFinders)();
    const checkboxRef = _react.useRef(null);
    const isSelectable = [
        selected,
        defaultSelected,
        onSelectionChange
    ].some((prop)=>typeof prop !== 'undefined');
    const [isCardSelected, setIsCardSelected] = _react.useState(false);
    const [isSelectFocused, setIsSelectFocused] = _react.useState(false);
    const shouldRestrictTriggerAction = _react.useCallback((event)=>{
        if (!cardRef.current) {
            return false;
        }
        const focusableElements = findAllFocusable(cardRef.current);
        const target = event.target;
        const isElementInFocusableGroup = focusableElements.some((element)=>element.contains(target));
        const isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
        return isElementInFocusableGroup && !isCheckboxSlot;
    }, [
        cardRef,
        findAllFocusable
    ]);
    const onChangeHandler = _react.useCallback((event)=>{
        if (shouldRestrictTriggerAction(event)) {
            return;
        }
        const newCheckedValue = !isCardSelected;
        setIsCardSelected(newCheckedValue);
        if (onSelectionChange) {
            onSelectionChange(event, {
                selected: newCheckedValue
            });
        }
    }, [
        onSelectionChange,
        isCardSelected,
        shouldRestrictTriggerAction
    ]);
    const onKeyDownHandler = _react.useCallback((event)=>{
        if ([
            _keyboardKeys.Enter
        ].includes(event.key)) {
            event.preventDefault();
            onChangeHandler(event);
        }
    }, [
        onChangeHandler
    ]);
    const checkboxSlot = _react.useMemo(()=>{
        if (!isSelectable || floatingAction) {
            return;
        }
        const selectableCheckboxProps = {};
        if (referenceId) {
            selectableCheckboxProps['aria-labelledby'] = referenceId;
        } else if (referenceLabel) {
            selectableCheckboxProps['aria-label'] = referenceLabel;
        }
        return (0, _reactUtilities.resolveShorthand)(checkbox, {
            defaultProps: {
                ref: checkboxRef,
                type: 'checkbox',
                checked: isCardSelected,
                onChange: (event)=>onChangeHandler(event),
                onFocus: ()=>setIsSelectFocused(true),
                onBlur: ()=>setIsSelectFocused(false),
                ...selectableCheckboxProps
            }
        });
    }, [
        checkbox,
        floatingAction,
        isCardSelected,
        isSelectable,
        onChangeHandler,
        referenceId,
        referenceLabel
    ]);
    const floatingActionSlot = _react.useMemo(()=>{
        if (!floatingAction) {
            return;
        }
        return (0, _reactUtilities.resolveShorthand)(floatingAction, {
            defaultProps: {
                ref: checkboxRef
            }
        });
    }, [
        floatingAction
    ]);
    const selectableCardProps = _react.useMemo(()=>{
        if (!isSelectable) {
            return null;
        }
        return {
            onClick: (0, _reactUtilities.mergeCallbacks)(onClick, onChangeHandler),
            onKeyDown: (0, _reactUtilities.mergeCallbacks)(onKeyDown, onKeyDownHandler)
        };
    }, [
        isSelectable,
        onChangeHandler,
        onClick,
        onKeyDown,
        onKeyDownHandler
    ]);
    _react.useEffect(()=>setIsCardSelected(Boolean(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : selected)), [
        defaultSelected,
        selected,
        setIsCardSelected
    ]);
    return {
        selected: isCardSelected,
        selectable: isSelectable,
        selectFocused: isSelectFocused,
        selectableCardProps,
        checkboxSlot,
        floatingActionSlot
    };
}; //# sourceMappingURL=useCardSelectable.js.map

//# sourceMappingURL=useCardSelectable.js.map