"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useCombobox_unstable", {
    enumerable: true,
    get: ()=>useCombobox_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _keyboardKeys = require("@fluentui/keyboard-keys");
const _reactIcons = require("@fluentui/react-icons");
const _reactUtilities = require("@fluentui/react-utilities");
const _dropdownKeyActions = require("../../utils/dropdownKeyActions");
const _useComboboxBaseState = require("../../utils/useComboboxBaseState");
const _useComboboxPopup = require("../../utils/useComboboxPopup");
const _useTriggerListboxSlots = require("../../utils/useTriggerListboxSlots");
const _listbox = require("../Listbox/Listbox");
const useCombobox_unstable = (props, ref)=>{
    var _props_input;
    const baseState = (0, _useComboboxBaseState.useComboboxBaseState)({
        ...props,
        editable: true
    });
    const { activeOption , clearSelection , getIndexOfId , getOptionsMatchingText , hasFocus , open , selectOption , selectedOptions , setActiveOption , setFocusVisible , setOpen , setValue , value  } = baseState;
    const { disabled , freeform , inlinePopup , multiselect  } = props;
    const comboId = (0, _reactUtilities.useId)('combobox-');
    const { primary: triggerNativeProps , root: rootNativeProps  } = (0, _reactUtilities.getPartitionedNativeProps)({
        props,
        primarySlotTagName: 'input',
        excludedPropNames: [
            'children',
            'size'
        ]
    });
    const rootRef = _react.useRef(null);
    const triggerRef = _react.useRef(null);
    // NVDA and JAWS have bugs that suppress reading the input value text when aria-activedescendant is set
    // To prevent this, we clear the HTML attribute (but save the state) when a user presses left/right arrows
    // ref: https://github.com/microsoft/fluentui/issues/26359#issuecomment-1397759888
    const [hideActiveDescendant, setHideActiveDescendant] = _react.useState(false);
    // calculate listbox width style based on trigger width
    const [popupDimensions, setPopupDimensions] = _react.useState();
    _react.useEffect(()=>{
        // only recalculate width when opening
        if (open) {
            var _rootRef_current;
            const width = `${(_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.clientWidth}px`;
            if (width !== (popupDimensions === null || popupDimensions === void 0 ? void 0 : popupDimensions.width)) {
                setPopupDimensions({
                    width
                });
            }
        }
    }, [
        open,
        popupDimensions
    ]);
    // set active option and selection based on typing
    const getOptionFromInput = (inputValue)=>{
        const searchString = inputValue === null || inputValue === void 0 ? void 0 : inputValue.trim().toLowerCase();
        if (!searchString || searchString.length === 0) {
            return;
        }
        const matcher = (optionText)=>optionText.toLowerCase().indexOf(searchString) === 0;
        const matches = getOptionsMatchingText(matcher);
        // return first matching option after the current active option, looping back to the top
        if (matches.length > 1 && activeOption) {
            const startIndex = getIndexOfId(activeOption.id);
            const nextMatch = matches.find((option)=>getIndexOfId(option.id) >= startIndex);
            return nextMatch !== null && nextMatch !== void 0 ? nextMatch : matches[0];
        }
        var _matches_;
        return (_matches_ = matches[0]) !== null && _matches_ !== void 0 ? _matches_ : undefined;
    };
    /* Handle typed input */ // reset any typed value when an option is selected
    baseState.selectOption = (ev, option)=>{
        setValue(undefined);
        selectOption(ev, option);
    };
    const onTriggerBlur = (ev)=>{
        // handle selection and updating value if freeform is false
        if (!baseState.open && !freeform) {
            // select matching option, if the value fully matches
            if (value && activeOption && value.trim().toLowerCase() === (activeOption === null || activeOption === void 0 ? void 0 : activeOption.text.toLowerCase())) {
                baseState.selectOption(ev, activeOption);
            }
            // reset typed value when the input loses focus while collapsed, unless freeform is true
            setValue(undefined);
        }
    };
    baseState.setOpen = (ev, newState)=>{
        if (disabled) {
            return;
        }
        if (!newState && !freeform) {
            setValue(undefined);
        }
        setOpen(ev, newState);
    };
    // update value and active option based on input
    const onTriggerChange = (ev)=>{
        const inputValue = ev.target.value;
        // update uncontrolled value
        baseState.setValue(inputValue);
        // handle updating active option based on input
        const matchingOption = getOptionFromInput(inputValue);
        setActiveOption(matchingOption);
        setFocusVisible(true);
        // clear selection for single-select if the input value no longer matches the selection
        if (!multiselect && selectedOptions.length === 1 && (inputValue.length < 1 || !matchingOption)) {
            clearSelection(ev);
        }
    };
    // open Combobox when typing
    const onTriggerKeyDown = (ev)=>{
        if (!open && (0, _dropdownKeyActions.getDropdownActionFromKey)(ev) === 'Type') {
            baseState.setOpen(ev, true);
        }
        // clear activedescendant when moving the text insertion cursor
        if (ev.key === _keyboardKeys.ArrowLeft || ev.key === _keyboardKeys.ArrowRight) {
            setHideActiveDescendant(true);
        } else {
            setHideActiveDescendant(false);
        }
    };
    // resolve input and listbox slot props
    let triggerSlot;
    let listboxSlot;
    triggerSlot = (0, _reactUtilities.resolveShorthand)(props.input, {
        required: true,
        defaultProps: {
            ref: (0, _reactUtilities.useMergedRefs)((_props_input = props.input) === null || _props_input === void 0 ? void 0 : _props_input.ref, triggerRef),
            type: 'text',
            value: value !== null && value !== void 0 ? value : '',
            ...triggerNativeProps
        }
    });
    triggerSlot.onChange = (0, _reactUtilities.mergeCallbacks)(triggerSlot.onChange, onTriggerChange);
    triggerSlot.onBlur = (0, _reactUtilities.mergeCallbacks)(triggerSlot.onBlur, onTriggerBlur);
    triggerSlot.onKeyDown = (0, _reactUtilities.mergeCallbacks)(triggerSlot.onKeyDown, onTriggerKeyDown);
    // only resolve listbox slot if needed
    listboxSlot = open || hasFocus ? (0, _reactUtilities.resolveShorthand)(props.listbox, {
        required: true,
        defaultProps: {
            children: props.children,
            style: popupDimensions
        }
    }) : undefined;
    [triggerSlot, listboxSlot] = (0, _useComboboxPopup.useComboboxPopup)(props, triggerSlot, listboxSlot);
    [triggerSlot, listboxSlot] = (0, _useTriggerListboxSlots.useTriggerListboxSlots)(props, baseState, ref, triggerSlot, listboxSlot);
    if (hideActiveDescendant) {
        triggerSlot['aria-activedescendant'] = undefined;
    }
    const state = {
        components: {
            root: 'div',
            input: 'input',
            expandIcon: 'span',
            listbox: _listbox.Listbox
        },
        root: (0, _reactUtilities.resolveShorthand)(props.root, {
            required: true,
            defaultProps: {
                'aria-owns': !inlinePopup ? listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.id : undefined,
                ...rootNativeProps
            }
        }),
        input: triggerSlot,
        listbox: listboxSlot,
        expandIcon: (0, _reactUtilities.resolveShorthand)(props.expandIcon, {
            required: true,
            defaultProps: {
                'aria-expanded': open,
                children: /*#__PURE__*/ _react.createElement(_reactIcons.ChevronDownRegular, null),
                role: 'button'
            }
        }),
        ...baseState
    };
    state.root.ref = (0, _reactUtilities.useMergedRefs)(state.root.ref, rootRef);
    /* handle open/close + focus change when clicking expandIcon */ const { onMouseDown: onIconMouseDown , onClick: onIconClick  } = state.expandIcon || {};
    const onExpandIconMouseDown = (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)(onIconMouseDown, ()=>{
        // do not dismiss on blur when closing via clicking the icon
        if (open) {
            baseState.ignoreNextBlur.current = true;
        }
    }));
    const onExpandIconClick = (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)(onIconClick, (event)=>{
        var _triggerRef_current;
        // open and set focus
        state.setOpen(event, !state.open);
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
        // set focus visible=false, since this can only be done with the mouse/pointer
        setFocusVisible(false);
    }));
    if (state.expandIcon) {
        state.expandIcon.onMouseDown = onExpandIconMouseDown;
        state.expandIcon.onClick = onExpandIconClick;
        // If there is no explicit aria-label, calculate default accName attribute for expandIcon button,
        // using the following steps:
        // 1. If there is an aria-label, it is "Open [aria-label]"
        // 2. If there is an aria-labelledby, it is "Open [aria-labelledby target]" (using aria-labelledby + ids)
        // 3. If there is no aria-label/ledby attr, it falls back to "Open"
        // We can't fall back to a label/htmlFor name because of https://github.com/w3c/accname/issues/179
        const hasExpandLabel = state.expandIcon['aria-label'] || state.expandIcon['aria-labelledby'];
        const defaultOpenString = 'Open'; // this is english-only since it is the fallback
        if (!hasExpandLabel) {
            if (props['aria-labelledby']) {
                var _state_expandIcon_id;
                const chevronId = (_state_expandIcon_id = state.expandIcon.id) !== null && _state_expandIcon_id !== void 0 ? _state_expandIcon_id : `${comboId}-chevron`;
                const chevronLabelledBy = `${chevronId} ${state.input['aria-labelledby']}`;
                state.expandIcon['aria-label'] = defaultOpenString;
                state.expandIcon.id = chevronId;
                state.expandIcon['aria-labelledby'] = chevronLabelledBy;
            } else if (props['aria-label']) {
                state.expandIcon['aria-label'] = `${defaultOpenString} ${props['aria-label']}`;
            } else {
                state.expandIcon['aria-label'] = defaultOpenString;
            }
        }
    }
    return state;
}; //# sourceMappingURL=useCombobox.js.map

//# sourceMappingURL=useCombobox.js.map