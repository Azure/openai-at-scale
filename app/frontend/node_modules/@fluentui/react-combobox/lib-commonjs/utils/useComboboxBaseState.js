"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useComboboxBaseState", {
    enumerable: true,
    get: ()=>useComboboxBaseState
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _useOptionCollection = require("../utils/useOptionCollection");
const _useSelection = require("../utils/useSelection");
const useComboboxBaseState = (props)=>{
    const { appearance ='outline' , children , editable =false , inlinePopup =false , multiselect , onOpenChange , size ='medium'  } = props;
    const optionCollection = (0, _useOptionCollection.useOptionCollection)();
    const { getOptionAtIndex , getOptionsMatchingValue  } = optionCollection;
    const [activeOption, setActiveOption] = _react.useState();
    // track whether keyboard focus outline should be shown
    // tabster/keyborg doesn't work here, since the actual keyboard focus target doesn't move
    const [focusVisible, setFocusVisible] = _react.useState(false);
    // track focused state to conditionally render collapsed listbox
    const [hasFocus, setHasFocus] = _react.useState(false);
    const ignoreNextBlur = _react.useRef(false);
    const selectionState = (0, _useSelection.useSelection)(props);
    const { selectedOptions  } = selectionState;
    // calculate value based on props, internal value changes, and selected options
    const isFirstMount = (0, _reactUtilities.useFirstMount)();
    const [controllableValue, setValue] = (0, _reactUtilities.useControllableState)({
        state: props.value,
        initialState: undefined
    });
    const value = _react.useMemo(()=>{
        // don't compute the value if it is defined through props or setValue,
        if (controllableValue !== undefined) {
            return controllableValue;
        }
        // handle defaultValue here, so it is overridden by selection
        if (isFirstMount && props.defaultValue !== undefined) {
            return props.defaultValue;
        }
        const selectedOptionsText = getOptionsMatchingValue((optionValue)=>{
            return selectedOptions.includes(optionValue);
        }).map((option)=>option.text);
        if (multiselect) {
            // editable inputs should not display multiple selected options in the input as text
            return editable ? '' : selectedOptionsText.join(', ');
        }
        return selectedOptionsText[0];
    // do not change value after isFirstMount changes,
    // we do not want to accidentally override defaultValue on a second render
    // unless another value is intentionally set
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        controllableValue,
        editable,
        getOptionsMatchingValue,
        multiselect,
        props.defaultValue,
        selectedOptions
    ]);
    // Handle open state, which is shared with options in context
    const [open, setOpenState] = (0, _reactUtilities.useControllableState)({
        state: props.open,
        defaultState: props.defaultOpen,
        initialState: false
    });
    const setOpen = _react.useCallback((event, newState)=>{
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {
            open: newState
        });
        setOpenState(newState);
    }, [
        onOpenChange,
        setOpenState
    ]);
    // update active option based on change in open state or children
    _react.useEffect(()=>{
        if (open && !activeOption) {
            // if it is single-select and there is a selected option, start at the selected option
            if (!multiselect && selectedOptions.length > 0) {
                const selectedOption = getOptionsMatchingValue((v)=>v === selectedOptions[0]).pop();
                selectedOption && setActiveOption(selectedOption);
            } else {
                setActiveOption(getOptionAtIndex(0));
            }
        } else if (!open) {
            // reset the active option when closing
            setActiveOption(undefined);
        }
    // this should only be run in response to changes in the open state or children
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        open,
        children
    ]);
    return {
        ...optionCollection,
        ...selectionState,
        activeOption,
        appearance,
        focusVisible,
        hasFocus,
        ignoreNextBlur,
        inlinePopup,
        open,
        setActiveOption,
        setFocusVisible,
        setHasFocus,
        setOpen,
        setValue,
        size,
        value
    };
}; //# sourceMappingURL=useComboboxBaseState.js.map

//# sourceMappingURL=useComboboxBaseState.js.map