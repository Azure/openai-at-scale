"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useOptionCollection", {
    enumerable: true,
    get: ()=>useOptionCollection
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const useOptionCollection = ()=>{
    const nodes = _react.useRef([]);
    const collectionAPI = _react.useMemo(()=>{
        const getCount = ()=>nodes.current.length;
        const getOptionAtIndex = (index)=>{
            var _nodes_current_index;
            return (_nodes_current_index = nodes.current[index]) === null || _nodes_current_index === void 0 ? void 0 : _nodes_current_index.option;
        };
        const getIndexOfId = (id)=>nodes.current.findIndex((node)=>node.option.id === id);
        const getOptionById = (id)=>{
            const item = nodes.current.find((node)=>node.option.id === id);
            return item === null || item === void 0 ? void 0 : item.option;
        };
        const getOptionsMatchingText = (matcher)=>{
            return nodes.current.filter((node)=>matcher(node.option.text)).map((node)=>node.option);
        };
        const getOptionsMatchingValue = (matcher)=>{
            return nodes.current.filter((node)=>matcher(node.option.value)).map((node)=>node.option);
        };
        return {
            getCount,
            getOptionAtIndex,
            getIndexOfId,
            getOptionById,
            getOptionsMatchingText,
            getOptionsMatchingValue
        };
    }, []);
    const registerOption = _react.useCallback((option, element)=>{
        var _nodes_current_index;
        const index = nodes.current.findIndex((node)=>{
            if (!node.element || !element) {
                return false;
            }
            if (node.option.id === option.id) {
                return true;
            }
            // use the DOM method compareDocumentPosition to order the current node against registered nodes
            // eslint-disable-next-line no-bitwise
            return node.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING;
        });
        // do not register the option if it already exists
        if (((_nodes_current_index = nodes.current[index]) === null || _nodes_current_index === void 0 ? void 0 : _nodes_current_index.option.id) !== option.id) {
            const newItem = {
                element,
                option
            };
            // If an index is not found we will push the element to the end.
            if (index === -1) {
                nodes.current = [
                    ...nodes.current,
                    newItem
                ];
            } else {
                nodes.current.splice(index, 0, newItem);
            }
        }
        // return the unregister function
        return ()=>{
            nodes.current = nodes.current.filter((node)=>node.option.id !== option.id);
        };
    }, []);
    return {
        ...collectionAPI,
        options: nodes.current.map((node)=>node.option),
        registerOption
    };
}; //# sourceMappingURL=useOptionCollection.js.map

//# sourceMappingURL=useOptionCollection.js.map