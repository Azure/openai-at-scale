"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTriggerListboxSlots", {
    enumerable: true,
    get: ()=>useTriggerListboxSlots
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _dropdownKeyActions = require("../utils/dropdownKeyActions");
function useTriggerListboxSlots(props, state, ref, triggerSlot, listboxSlot) {
    const { multiselect  } = props;
    const { activeOption , getCount , getIndexOfId , getOptionAtIndex , ignoreNextBlur , open , selectOption , setActiveOption , setFocusVisible , setHasFocus , setOpen  } = state;
    // handle trigger focus/blur
    const triggerRef = _react.useRef(null);
    // resolve listbox shorthand props
    const listboxId = (0, _reactUtilities.useId)('fluent-listbox', listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.id);
    const listbox = listboxSlot && {
        id: listboxId,
        multiselect,
        tabIndex: undefined,
        ...listboxSlot
    };
    // resolve trigger shorthand props
    const trigger = {
        'aria-expanded': open,
        'aria-activedescendant': open ? activeOption === null || activeOption === void 0 ? void 0 : activeOption.id : undefined,
        role: 'combobox',
        ...triggerSlot,
        // explicitly type the ref as an intersection here to prevent type errors
        // since the `children` prop has mutually incompatible types between input/button
        // functionally both ref and triggerRef will always be the same element type
        ref: (0, _reactUtilities.useMergedRefs)(ref, triggerSlot === null || triggerSlot === void 0 ? void 0 : triggerSlot.ref, triggerRef)
    };
    /*
  * Handle focus when clicking the listbox popup:
  * 1. Move focus back to the button/input when the listbox is clicked (otherwise it goes to body)
  * 2. Do not close the listbox on button/input blur when clicking into the listbox
  */ const listboxOnClick = (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)((event)=>{
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
    }, listbox === null || listbox === void 0 ? void 0 : listbox.onClick));
    const listboxOnMouseOver = (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)((event)=>{
        setFocusVisible(false);
    }, listbox === null || listbox === void 0 ? void 0 : listbox.onMouseOver));
    const listboxOnMouseDown = (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)((event)=>{
        ignoreNextBlur.current = true;
    }, listbox === null || listbox === void 0 ? void 0 : listbox.onMouseDown));
    // listbox is nullable, only add event handlers if it exists
    if (listbox) {
        listbox.onClick = listboxOnClick;
        listbox.onMouseOver = listboxOnMouseOver;
        listbox.onMouseDown = listboxOnMouseDown;
    }
    // the trigger should open/close the popup on click or blur
    trigger.onBlur = (0, _reactUtilities.mergeCallbacks)((event)=>{
        if (!ignoreNextBlur.current) {
            setOpen(event, false);
        }
        ignoreNextBlur.current = false;
        setHasFocus(false);
    }, trigger.onBlur);
    trigger.onClick = (0, _reactUtilities.mergeCallbacks)((event)=>{
        setOpen(event, !open);
    }, trigger.onClick);
    trigger.onFocus = (0, _reactUtilities.mergeCallbacks)((event)=>{
        setHasFocus(true);
    }, trigger.onFocus);
    // handle combobox keyboard interaction
    trigger.onKeyDown = (0, _reactUtilities.mergeCallbacks)((event)=>{
        const action = (0, _dropdownKeyActions.getDropdownActionFromKey)(event, {
            open,
            multiselect
        });
        const maxIndex = getCount() - 1;
        const activeIndex = activeOption ? getIndexOfId(activeOption.id) : -1;
        let newIndex = activeIndex;
        switch(action){
            case 'Open':
                event.preventDefault();
                setFocusVisible(true);
                setOpen(event, true);
                break;
            case 'Close':
                // stop propagation for escape key to avoid dismissing any parent popups
                event.stopPropagation();
                event.preventDefault();
                setOpen(event, false);
                break;
            case 'CloseSelect':
                !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(event, false);
            // fallthrough
            case 'Select':
                activeOption && selectOption(event, activeOption);
                event.preventDefault();
                break;
            case 'Tab':
                !multiselect && activeOption && selectOption(event, activeOption);
                break;
            default:
                newIndex = (0, _dropdownKeyActions.getIndexFromAction)(action, activeIndex, maxIndex);
        }
        if (newIndex !== activeIndex) {
            // prevent default page scroll/keyboard action if the index changed
            event.preventDefault();
            setActiveOption(getOptionAtIndex(newIndex));
            setFocusVisible(true);
        }
    }, trigger.onKeyDown);
    trigger.onMouseOver = (0, _reactUtilities.mergeCallbacks)((event)=>{
        setFocusVisible(false);
    }, trigger.onMouseOver);
    return [
        trigger,
        listbox
    ];
} //# sourceMappingURL=useTriggerListboxSlots.js.map

//# sourceMappingURL=useTriggerListboxSlots.js.map