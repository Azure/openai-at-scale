"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useDialog_unstable", {
    enumerable: true,
    get: ()=>useDialog_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactContextSelector = require("@fluentui/react-context-selector");
const _utils = require("../../utils");
const _contexts = require("../../contexts");
const useDialog_unstable = (props)=>{
    const { children , modalType ='modal' , onOpenChange , inertTrapFocus =false  } = props;
    const [trigger, content] = childrenToTriggerAndContent(children);
    const [open, setOpen] = (0, _reactUtilities.useControllableState)({
        state: props.open,
        defaultState: props.defaultOpen,
        initialState: false
    });
    const requestOpenChange = (0, _reactUtilities.useEventCallback)((data)=>{
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(data.event, data);
        // if user prevents default then do not change state value
        // otherwise updates state value and trigger reference to the element that caused the opening
        if (!data.event.isDefaultPrevented()) {
            setOpen(data.open);
        }
    });
    const focusRef = (0, _utils.useFocusFirstElement)(open, modalType);
    const disableBodyScroll = (0, _utils.useDisableBodyScroll)();
    const isBodyScrollLocked = Boolean(open && modalType !== 'non-modal');
    (0, _reactUtilities.useIsomorphicLayoutEffect)(()=>{
        if (isBodyScrollLocked) {
            return disableBodyScroll();
        }
    }, [
        disableBodyScroll,
        isBodyScrollLocked
    ]);
    return {
        components: {
            backdrop: 'div'
        },
        inertTrapFocus,
        open,
        modalType,
        content: open ? content : null,
        trigger,
        requestOpenChange,
        dialogTitleId: (0, _reactUtilities.useId)('dialog-title-'),
        isNestedDialog: (0, _reactContextSelector.useHasParentContext)(_contexts.DialogContext),
        dialogRef: focusRef
    };
};
/**
 * Extracts trigger and content from children
 */ function childrenToTriggerAndContent(children) {
    const childrenArray = _react.Children.toArray(children);
    if (process.env.NODE_ENV !== 'production') {
        if (childrenArray.length !== 1 && childrenArray.length !== 2) {
            // eslint-disable-next-line no-console
            console.warn('Dialog must contain at least one child <DialogSurface/>,\n' + 'and at most two children <DialogTrigger/> <DialogSurface/> (in this order)');
        }
    }
    switch(childrenArray.length){
        // case where there's a trigger followed by content
        case 2:
            return childrenArray;
        // case where there's only content
        case 1:
            return [
                undefined,
                childrenArray[0]
            ];
        // unknown case
        default:
            return [
                undefined,
                undefined
            ];
    }
} //# sourceMappingURL=useDialog.js.map

//# sourceMappingURL=useDialog.js.map