"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMenuPopover_unstable", {
    enumerable: true,
    get: ()=>useMenuPopover_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _keyboardKeys = require("@fluentui/keyboard-keys");
const _reactUtilities = require("@fluentui/react-utilities");
const _menuContext = require("../../contexts/menuContext");
const _index = require("../../utils/index");
const _reactSharedContexts = require("@fluentui/react-shared-contexts");
const _useIsSubmenu = require("../../utils/useIsSubmenu");
const useMenuPopover_unstable = (props, ref)=>{
    const popoverRef = (0, _menuContext.useMenuContext_unstable)((context)=>context.menuPopoverRef);
    const setOpen = (0, _menuContext.useMenuContext_unstable)((context)=>context.setOpen);
    const open = (0, _menuContext.useMenuContext_unstable)((context)=>context.open);
    const openOnHover = (0, _menuContext.useMenuContext_unstable)((context)=>context.openOnHover);
    const isSubmenu = (0, _useIsSubmenu.useIsSubmenu)();
    const canDispatchCustomEventRef = _react.useRef(true);
    const throttleDispatchTimerRef = _react.useRef(0);
    const { dir  } = (0, _reactSharedContexts.useFluent_unstable)();
    const CloseArrowKey = dir === 'ltr' ? _keyboardKeys.ArrowLeft : _keyboardKeys.ArrowRight;
    // use DOM listener since react events propagate up the react tree
    // no need to do `contains` logic as menus are all positioned in different portals
    const mouseOverListenerCallbackRef = _react.useCallback((node)=>{
        if (node) {
            // Dispatches the custom menu mouse enter event with throttling
            // Needs to trigger on mouseover to support keyboard + mouse together
            // i.e. keyboard opens submenus while cursor is still on the parent
            node.addEventListener('mouseover', (e)=>{
                if (canDispatchCustomEventRef.current) {
                    canDispatchCustomEventRef.current = false;
                    (0, _index.dispatchMenuEnterEvent)(popoverRef.current, e);
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore #16889 Node setTimeout type leaking
                    throttleDispatchTimerRef.current = setTimeout(()=>canDispatchCustomEventRef.current = true, 250);
                }
            });
        }
    }, [
        popoverRef,
        throttleDispatchTimerRef
    ]);
    _react.useEffect(()=>{
        ()=>clearTimeout(throttleDispatchTimerRef.current);
    }, []);
    var _useMenuContext_unstable;
    const inline = (_useMenuContext_unstable = (0, _menuContext.useMenuContext_unstable)((context)=>context.inline)) !== null && _useMenuContext_unstable !== void 0 ? _useMenuContext_unstable : false;
    const mountNode = (0, _menuContext.useMenuContext_unstable)((context)=>context.mountNode);
    const rootProps = (0, _reactUtilities.getNativeElementProps)('div', {
        role: 'presentation',
        ...props,
        ref: (0, _reactUtilities.useMergedRefs)(ref, popoverRef, mouseOverListenerCallbackRef)
    });
    const { onMouseEnter: onMouseEnterOriginal , onKeyDown: onKeyDownOriginal  } = rootProps;
    rootProps.onMouseEnter = (0, _reactUtilities.useEventCallback)((event)=>{
        if (openOnHover) {
            setOpen(event, {
                open: true,
                keyboard: false,
                type: 'menuPopoverMouseEnter',
                event
            });
        }
        onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(event);
    });
    rootProps.onKeyDown = (0, _reactUtilities.useEventCallback)((event)=>{
        const key = event.key;
        if (key === _keyboardKeys.Escape || isSubmenu && key === CloseArrowKey) {
            var _popoverRef_current;
            if (open && ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(event.target))) {
                setOpen(event, {
                    open: false,
                    keyboard: true,
                    type: 'menuPopoverKeyDown',
                    event
                });
                // stop propagation to avoid conflicting with other elements that listen for `Escape`
                // e,g: Dialog, Popover and Tooltip
                event.stopPropagation();
            }
        }
        if (key === _keyboardKeys.Tab) {
            setOpen(event, {
                open: false,
                keyboard: true,
                type: 'menuPopoverKeyDown',
                event
            });
        }
        onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(event);
    });
    return {
        inline,
        mountNode,
        components: {
            root: 'div'
        },
        root: rootProps
    };
}; //# sourceMappingURL=useMenuPopover.js.map

//# sourceMappingURL=useMenuPopover.js.map