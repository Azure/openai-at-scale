{"version":3,"sources":["../../lib/utils/useOnMenuEnter.js"],"sourcesContent":["import * as React from 'react';\nimport { useEventCallback } from '@fluentui/react-utilities';\nimport { elementContains } from '@fluentui/react-portal';\n/**\n * Name of the custom event\n */\nexport const MENU_ENTER_EVENT = 'fuimenuenter';\n/**\n * This hook works similarly to @see {useOnClickOutside}\n *\n * Problem: Trying to behave the same as system menus:\n * When the mouse leaves a stack of nested menus the stack should not dismiss.\n * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.\n *\n * We don't use the native mouseenter event because it would trigger too many times in the document\n * Instead, dispatch custom DOM event from the menu so that it can bubble\n * Each nested menu can use the listener to check if the event is from a child or parent menu\n */\nexport const useOnMenuMouseEnter = options => {\n  const {\n    refs,\n    callback,\n    element,\n    disabled\n  } = options;\n  // Keep mouse event here because this is essentially a custom 'mouseenter' event\n  const listener = useEventCallback(ev => {\n    const popoverRef = refs[0];\n    const someMenuPopover = ev.target;\n    var _popoverRef_current;\n    // someMenu is a child -> will always be contained because of vParents\n    // someMenu is a parent -> will always not be contained because no vParent\n    // someMenu is the current popover -> it will contain itself\n    const isOutsidePopover = !elementContains((_popoverRef_current = popoverRef.current) !== null && _popoverRef_current !== void 0 ? _popoverRef_current : null, someMenuPopover);\n    if (isOutsidePopover && !disabled) {\n      callback(ev);\n    }\n  });\n  React.useEffect(() => {\n    // eslint-disable-next-line eqeqeq\n    if (element == null) {\n      return;\n    }\n    if (!disabled) {\n      element.addEventListener(MENU_ENTER_EVENT, listener);\n    }\n    return () => {\n      element.removeEventListener(MENU_ENTER_EVENT, listener);\n    };\n  }, [listener, element, disabled]);\n};\n/**\n * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`\n * @param el element for the event target\n * @param nativeEvent the native mouse event this is mapped to\n */\nexport const dispatchMenuEnterEvent = (el, nativeEvent) => {\n  el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, {\n    bubbles: true,\n    detail: {\n      nativeEvent\n    }\n  }));\n};\n//# sourceMappingURL=useOnMenuEnter.js.map"],"names":["MENU_ENTER_EVENT","useOnMenuMouseEnter","dispatchMenuEnterEvent","options","refs","callback","element","disabled","listener","useEventCallback","ev","popoverRef","someMenuPopover","target","_popoverRef_current","isOutsidePopover","elementContains","current","React","useEffect","addEventListener","removeEventListener","el","nativeEvent","dispatchEvent","CustomEvent","bubbles","detail"],"mappings":";;;;;;;;;;;IAMaA,gBAAgB,MAAhBA;IAYAC,mBAAmB,MAAnBA;IAsCAC,sBAAsB,MAAtBA;;;6DAxDU;gCACU;6BACD;AAIzB,MAAMF,mBAAmB;AAYzB,MAAMC,sBAAsBE,CAAAA,UAAW;IAC5C,MAAM,EACJC,KAAI,EACJC,SAAQ,EACRC,QAAO,EACPC,SAAQ,EACT,GAAGJ;IACJ,gFAAgF;IAChF,MAAMK,WAAWC,IAAAA,gCAAgB,EAACC,CAAAA,KAAM;QACtC,MAAMC,aAAaP,IAAI,CAAC,EAAE;QAC1B,MAAMQ,kBAAkBF,GAAGG,MAAM;QACjC,IAAIC;QACJ,sEAAsE;QACtE,0EAA0E;QAC1E,4DAA4D;QAC5D,MAAMC,mBAAmB,CAACC,IAAAA,4BAAe,EAAC,AAACF,CAAAA,sBAAsBH,WAAWM,OAAO,AAAD,MAAO,IAAI,IAAIH,wBAAwB,KAAK,IAAIA,sBAAsB,IAAI,EAAEF;QAC9J,IAAIG,oBAAoB,CAACR,UAAU;YACjCF,SAASK;QACX,CAAC;IACH;IACAQ,OAAMC,SAAS,CAAC,IAAM;QACpB,kCAAkC;QAClC,IAAIb,WAAW,IAAI,EAAE;YACnB;QACF,CAAC;QACD,IAAI,CAACC,UAAU;YACbD,QAAQc,gBAAgB,CAACpB,kBAAkBQ;QAC7C,CAAC;QACD,OAAO,IAAM;YACXF,QAAQe,mBAAmB,CAACrB,kBAAkBQ;QAChD;IACF,GAAG;QAACA;QAAUF;QAASC;KAAS;AAClC;AAMO,MAAML,yBAAyB,CAACoB,IAAIC,cAAgB;IACzDD,GAAGE,aAAa,CAAC,IAAIC,YAAYzB,kBAAkB;QACjD0B,SAAS,IAAI;QACbC,QAAQ;YACNJ;QACF;IACF;AACF,GACA,0CAA0C"}