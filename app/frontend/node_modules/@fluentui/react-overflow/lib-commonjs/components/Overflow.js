"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Overflow", {
    enumerable: true,
    get: ()=>Overflow
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _react1 = require("@griffel/react");
const _reactUtilities = require("@fluentui/react-utilities");
const _overflowContext = require("../overflowContext");
const _useOverflowContainer = require("../useOverflowContainer");
const useStyles = /*#__PURE__*/ (0, _react1["__styles"])({
    overflowMenu: {
        Brvla84: "fyfkpbf"
    },
    overflowingItems: {
        Hevnzl: "ftz08xh"
    }
}, {
    d: [
        ".fyfkpbf [data-overflow-menu]{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}",
        ".ftz08xh>[data-overflowing]{display:none;}"
    ]
});
const Overflow = /*#__PURE__*/ _react.forwardRef((props, ref)=>{
    const styles = useStyles();
    const { children , minimumVisible , overflowAxis ='horizontal' , overflowDirection , padding  } = props;
    const [hasOverflow, setHasOverflow] = _react.useState(false);
    const [itemVisibility, setItemVisibility] = _react.useState({});
    const [groupVisibility, setGroupVisibility] = _react.useState({});
    // useOverflowContainer wraps this method in a useEventCallback.
    // TODO: Do we need a useEventCallback here too?
    const update = (data)=>{
        setHasOverflow(()=>data.invisibleItems.length > 0);
        setItemVisibility(()=>{
            const newState = {};
            data.visibleItems.forEach((x)=>newState[x.id] = true);
            data.invisibleItems.forEach((x)=>newState[x.id] = false);
            return newState;
        });
        setGroupVisibility(data.groupVisibility);
    };
    const { containerRef , registerItem , updateOverflow , registerOverflowMenu  } = (0, _useOverflowContainer.useOverflowContainer)(update, {
        overflowDirection,
        overflowAxis,
        padding,
        minimumVisible,
        onUpdateItemVisibility: _useOverflowContainer.updateVisibilityAttribute
    });
    const clonedChild = (0, _reactUtilities.applyTriggerPropsToChildren)(children, {
        ref: (0, _reactUtilities.useMergedRefs)(containerRef, ref),
        className: (0, _react1.mergeClasses)(styles.overflowMenu, styles.overflowingItems, children.props.className)
    });
    return /*#__PURE__*/ _react.createElement(_overflowContext.OverflowContext.Provider, {
        value: {
            itemVisibility,
            groupVisibility,
            hasOverflow,
            registerItem,
            updateOverflow,
            registerOverflowMenu
        }
    }, clonedChild);
}); //# sourceMappingURL=Overflow.js.map

//# sourceMappingURL=Overflow.js.map