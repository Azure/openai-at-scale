"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useOverflowContainer: ()=>useOverflowContainer,
    updateVisibilityAttribute: ()=>updateVisibilityAttribute
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _priorityOverflow = require("@fluentui/priority-overflow");
const _reactUtilities = require("@fluentui/react-utilities");
const _constants = require("./constants");
const useOverflowContainer = (update, options)=>{
    const { overflowAxis , overflowDirection , padding , minimumVisible , onUpdateItemVisibility  } = options;
    // DOM ref to the overflow container element
    const containerRef = _react.useRef(null);
    const updateOverflowItems = (0, _reactUtilities.useEventCallback)(update);
    const [overflowManager] = _react.useState(()=>(0, _reactUtilities.canUseDOM)() ? (0, _priorityOverflow.createOverflowManager)() : null);
    (0, _reactUtilities.useIsomorphicLayoutEffect)(()=>{
        if (!containerRef.current) {
            return;
        }
        if (overflowManager) {
            overflowManager.observe(containerRef.current, {
                overflowDirection: overflowDirection !== null && overflowDirection !== void 0 ? overflowDirection : 'end',
                overflowAxis: overflowAxis !== null && overflowAxis !== void 0 ? overflowAxis : 'horizontal',
                padding: padding !== null && padding !== void 0 ? padding : 10,
                minimumVisible: minimumVisible !== null && minimumVisible !== void 0 ? minimumVisible : 0,
                onUpdateItemVisibility: onUpdateItemVisibility !== null && onUpdateItemVisibility !== void 0 ? onUpdateItemVisibility : ()=>undefined,
                onUpdateOverflow: updateOverflowItems !== null && updateOverflowItems !== void 0 ? updateOverflowItems : ()=>undefined
            });
            return ()=>{
                overflowManager.disconnect();
            };
        }
    }, [
        updateOverflowItems,
        overflowManager,
        overflowDirection,
        overflowAxis,
        padding,
        minimumVisible,
        onUpdateItemVisibility
    ]);
    const registerItem = _react.useCallback((item)=>{
        overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addItem(item);
        item.element.setAttribute(_constants.DATA_OVERFLOW_ITEM, '');
        return ()=>{
            item.element.removeAttribute(_constants.DATA_OVERFLOWING);
            item.element.removeAttribute(_constants.DATA_OVERFLOW_ITEM);
            overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeItem(item.id);
        };
    }, [
        overflowManager
    ]);
    const updateOverflow = _react.useCallback(()=>{
        overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.update();
    }, [
        overflowManager
    ]);
    const registerOverflowMenu = _react.useCallback((el)=>{
        overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addOverflowMenu(el);
        el.setAttribute(_constants.DATA_OVERFLOW_MENU, '');
        return ()=>{
            overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeOverflowMenu();
            el.removeAttribute(_constants.DATA_OVERFLOW_MENU);
        };
    }, [
        overflowManager
    ]);
    return {
        containerRef,
        registerItem,
        updateOverflow,
        registerOverflowMenu
    };
};
const updateVisibilityAttribute = ({ item , visible  })=>{
    if (visible) {
        item.element.removeAttribute(_constants.DATA_OVERFLOWING);
    } else {
        item.element.setAttribute(_constants.DATA_OVERFLOWING, '');
    }
}; //# sourceMappingURL=useOverflowContainer.js.map

//# sourceMappingURL=useOverflowContainer.js.map