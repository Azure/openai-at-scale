"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "usePopover_unstable", {
    enumerable: true,
    get: ()=>usePopover_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactSharedContexts = require("@fluentui/react-shared-contexts");
const _reactPositioning = require("@fluentui/react-positioning");
const _reactPortal = require("@fluentui/react-portal");
const _reactTabster = require("@fluentui/react-tabster");
const _index = require("../PopoverSurface/index");
const _constants = require("./constants");
const usePopover_unstable = (props)=>{
    const [contextTarget, setContextTarget] = (0, _reactPositioning.usePositioningMouseTarget)();
    const initialState = {
        size: 'medium',
        contextTarget,
        setContextTarget,
        ...props
    };
    const children = _react.Children.toArray(props.children);
    if (process.env.NODE_ENV !== 'production') {
        if (children.length === 0) {
            // eslint-disable-next-line no-console
            console.warn('Popover must contain at least one child');
        }
        if (children.length > 2) {
            // eslint-disable-next-line no-console
            console.warn('Popover must contain at most two children');
        }
    }
    let popoverTrigger = undefined;
    let popoverSurface = undefined;
    if (children.length === 2) {
        popoverTrigger = children[0];
        popoverSurface = children[1];
    } else if (children.length === 1) {
        popoverSurface = children[0];
    }
    const [open, setOpenState] = useOpenState(initialState);
    const setOpenTimeoutRef = _react.useRef(0);
    const setOpen = (0, _reactUtilities.useEventCallback)((e, shouldOpen)=>{
        clearTimeout(setOpenTimeoutRef.current);
        if (!(e instanceof Event) && e.persist) {
            // < React 17 still uses pooled synthetic events
            e.persist();
        }
        if (e.type === 'mouseleave') {
            var _props_mouseLeaveDelay;
            // FIXME leaking Node timeout type
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            setOpenTimeoutRef.current = setTimeout(()=>{
                setOpenState(e, shouldOpen);
            }, (_props_mouseLeaveDelay = props.mouseLeaveDelay) !== null && _props_mouseLeaveDelay !== void 0 ? _props_mouseLeaveDelay : 500);
        } else {
            setOpenState(e, shouldOpen);
        }
    });
    // Clear timeout on unmount
    // Setting state after a component unmounts can cause memory leaks
    _react.useEffect(()=>{
        return ()=>{
            clearTimeout(setOpenTimeoutRef.current);
        };
    }, []);
    const toggleOpen = _react.useCallback((e)=>{
        setOpen(e, !open);
    }, [
        setOpen,
        open
    ]);
    const positioningRefs = usePopoverRefs(initialState);
    const { targetDocument  } = (0, _reactSharedContexts.useFluent_unstable)();
    (0, _reactUtilities.useOnClickOutside)({
        contains: _reactPortal.elementContains,
        element: targetDocument,
        callback: (ev)=>setOpen(ev, false),
        refs: [
            positioningRefs.triggerRef,
            positioningRefs.contentRef
        ],
        disabled: !open
    });
    // only close on scroll for context, or when closeOnScroll is specified
    const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
    (0, _reactUtilities.useOnScrollOutside)({
        contains: _reactPortal.elementContains,
        element: targetDocument,
        callback: (ev)=>setOpen(ev, false),
        refs: [
            positioningRefs.triggerRef,
            positioningRefs.contentRef
        ],
        disabled: !open || !closeOnScroll
    });
    const { findFirstFocusable  } = (0, _reactTabster.useFocusFinders)();
    _react.useEffect(()=>{
        if (props.unstable_disableAutoFocus) {
            return;
        }
        if (open && positioningRefs.contentRef.current) {
            var _positioningRefs_contentRef_current_getAttribute;
            const containerTabIndex = (_positioningRefs_contentRef_current_getAttribute = positioningRefs.contentRef.current.getAttribute('tabIndex')) !== null && _positioningRefs_contentRef_current_getAttribute !== void 0 ? _positioningRefs_contentRef_current_getAttribute : undefined;
            const firstFocusable = isNaN(containerTabIndex) ? findFirstFocusable(positioningRefs.contentRef.current) : positioningRefs.contentRef.current;
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
        }
    }, [
        findFirstFocusable,
        open,
        positioningRefs.contentRef,
        props.unstable_disableAutoFocus
    ]);
    var _props_inline;
    return {
        ...initialState,
        ...positioningRefs,
        popoverTrigger,
        popoverSurface,
        open,
        setOpen,
        toggleOpen,
        setContextTarget,
        contextTarget,
        inline: (_props_inline = props.inline) !== null && _props_inline !== void 0 ? _props_inline : false
    };
};
/**
 * Creates and manages the Popover open state
 */ function useOpenState(state) {
    const onOpenChange = (0, _reactUtilities.useEventCallback)((e, data)=>{
        var _state_onOpenChange;
        return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e, data);
    });
    const [open, setOpenState] = (0, _reactUtilities.useControllableState)({
        state: state.open,
        defaultState: state.defaultOpen,
        initialState: false
    });
    state.open = open !== undefined ? open : state.open;
    const setContextTarget = state.setContextTarget;
    const setOpen = _react.useCallback((e, shouldOpen)=>{
        if (shouldOpen && e.type === 'contextmenu') {
            setContextTarget(e);
        }
        if (!shouldOpen) {
            setContextTarget(undefined);
        }
        setOpenState(shouldOpen);
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e, {
            open: shouldOpen
        });
    }, [
        setOpenState,
        onOpenChange,
        setContextTarget
    ]);
    return [
        open,
        setOpen
    ];
}
/**
 * Creates and sets the necessary trigger, target and content refs used by Popover
 */ function usePopoverRefs(state) {
    const positioningOptions = {
        position: 'above',
        align: 'center',
        arrowPadding: 2 * _constants.popoverSurfaceBorderRadius,
        target: state.openOnContext ? state.contextTarget : undefined,
        ...(0, _reactPositioning.resolvePositioningShorthand)(state.positioning)
    };
    // no reason to render arrow when covering the target
    if (positioningOptions.coverTarget) {
        state.withArrow = false;
    }
    if (state.withArrow) {
        positioningOptions.offset = (0, _reactPositioning.mergeArrowOffset)(positioningOptions.offset, _index.arrowHeights[state.size]);
    }
    const { targetRef: triggerRef , containerRef: contentRef , arrowRef  } = (0, _reactPositioning.usePositioning)(positioningOptions);
    return {
        triggerRef,
        contentRef,
        arrowRef
    };
} //# sourceMappingURL=usePopover.js.map

//# sourceMappingURL=usePopover.js.map