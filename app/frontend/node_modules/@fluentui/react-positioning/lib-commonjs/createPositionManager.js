"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createPositionManager", {
    enumerable: true,
    get: ()=>createPositionManager
});
const _dom = require("@floating-ui/dom");
const _utils = require("./utils");
const _reactUtilities = require("@fluentui/react-utilities");
function createPositionManager(options) {
    const { container , target , arrow , strategy , middleware , placement  } = options;
    let isDestroyed = false;
    if (!target || !container) {
        return {
            updatePosition: ()=>undefined,
            dispose: ()=>undefined
        };
    }
    let isFirstUpdate = true;
    const scrollParents = new Set();
    const targetWindow = container.ownerDocument.defaultView;
    // When the container is first resolved, set position `fixed` to avoid scroll jumps.
    // Without this scroll jumps can occur when the element is rendered initially and receives focus
    Object.assign(container.style, {
        position: 'fixed',
        left: 0,
        top: 0,
        margin: 0
    });
    const forceUpdate = ()=>{
        // debounced update can still occur afterwards
        // early return to avoid memory leaks
        if (isDestroyed) {
            return;
        }
        if (isFirstUpdate) {
            scrollParents.add((0, _utils.getScrollParent)(container));
            if ((0, _reactUtilities.isHTMLElement)(target)) {
                scrollParents.add((0, _utils.getScrollParent)(target));
            }
            scrollParents.forEach((scrollParent)=>{
                scrollParent.addEventListener('scroll', updatePosition);
            });
            isFirstUpdate = false;
        }
        Object.assign(container.style, {
            position: strategy
        });
        (0, _dom.computePosition)(target, container, {
            placement,
            middleware,
            strategy
        }).then(({ x , y , middlewareData , placement: computedPlacement  })=>{
            // Promise can still resolve after destruction
            // early return to avoid applying outdated position
            if (isDestroyed) {
                return;
            }
            (0, _utils.writeArrowUpdates)({
                arrow,
                middlewareData
            });
            (0, _utils.writeContainerUpdates)({
                container,
                middlewareData,
                placement: computedPlacement,
                coordinates: {
                    x,
                    y
                },
                lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
                strategy
            });
        }).catch((err)=>{
            // https://github.com/floating-ui/floating-ui/issues/1845
            // FIXME for node > 14
            // node 15 introduces promise rejection which means that any components
            // tests need to be `it('', async () => {})` otherwise there can be race conditions with
            // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist
            // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing
            // will actually be counter productive
            if (process.env.NODE_ENV === 'development') {
                // eslint-disable-next-line no-console
                console.error('[usePositioning]: Failed to calculate position', err);
            }
        });
    };
    const updatePosition = (0, _utils.debounce)(()=>forceUpdate());
    const dispose = ()=>{
        isDestroyed = true;
        if (targetWindow) {
            targetWindow.removeEventListener('scroll', updatePosition);
            targetWindow.removeEventListener('resize', updatePosition);
        }
        scrollParents.forEach((scrollParent)=>{
            scrollParent.removeEventListener('scroll', updatePosition);
        });
    };
    if (targetWindow) {
        targetWindow.addEventListener('scroll', updatePosition);
        targetWindow.addEventListener('resize', updatePosition);
    }
    // Update the position on initialization
    updatePosition();
    return {
        updatePosition,
        dispose
    };
} //# sourceMappingURL=createPositionManager.js.map

//# sourceMappingURL=createPositionManager.js.map