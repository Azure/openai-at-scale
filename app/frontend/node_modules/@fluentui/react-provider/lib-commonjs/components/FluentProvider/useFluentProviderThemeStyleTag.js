"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useFluentProviderThemeStyleTag", {
    enumerable: true,
    get: ()=>useFluentProviderThemeStyleTag
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _reactUtilities = require("@fluentui/react-utilities");
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _useFluentProviderStyles = require("./useFluentProviderStyles");
// String concatenation is used to prevent bundlers to complain with older versions of React
const useInsertionEffect = _react['useInsertion' + 'Effect'] ? _react['useInsertion' + 'Effect'] : _reactUtilities.useIsomorphicLayoutEffect;
const createStyleTag = (target, elementAttributes)=>{
    if (!target) {
        return undefined;
    }
    const tag = target.createElement('style');
    Object.keys(elementAttributes).forEach((attrName)=>{
        tag.setAttribute(attrName, elementAttributes[attrName]);
    });
    target.head.appendChild(tag);
    return tag;
};
const insertSheet = (tag, rule)=>{
    const sheet = tag.sheet;
    if (sheet) {
        if (sheet.cssRules.length > 0) {
            sheet.deleteRule(0);
        }
        sheet.insertRule(rule, 0);
    } else if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line no-console
        console.error('FluentProvider: No sheet available on styleTag, styles will not be inserted into DOM.');
    }
};
const useFluentProviderThemeStyleTag = (options)=>{
    const { targetDocument , theme , rendererAttributes  } = options;
    const styleTag = _react.useRef();
    const styleTagId = (0, _reactUtilities.useId)(_useFluentProviderStyles.fluentProviderClassNames.root);
    const styleElementAttributes = rendererAttributes;
    const cssVarsAsString = _react.useMemo(()=>{
        return theme ? Object.keys(theme).reduce((cssVarRule, cssVar)=>{
            cssVarRule += `--${cssVar}: ${theme[cssVar]}; `;
            return cssVarRule;
        }, '') : '';
    }, [
        theme
    ]);
    const rule = `.${styleTagId} { ${cssVarsAsString} }`;
    useHandleSSRStyleElements(targetDocument, styleTagId);
    useInsertionEffect(()=>{
        // The style element could already have been created during SSR - no need to recreate it
        const ssrStyleElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(styleTagId);
        if (ssrStyleElement) {
            styleTag.current = ssrStyleElement;
        } else {
            styleTag.current = createStyleTag(targetDocument, {
                ...styleElementAttributes,
                id: styleTagId
            });
            if (styleTag.current) {
                insertSheet(styleTag.current, rule);
            }
        }
        return ()=>{
            var _styleTag_current;
            (_styleTag_current = styleTag.current) === null || _styleTag_current === void 0 ? void 0 : _styleTag_current.remove();
        };
    }, [
        styleTagId,
        targetDocument,
        rule,
        styleElementAttributes
    ]);
    return {
        styleTagId,
        rule
    };
};
function useHandleSSRStyleElements(targetDocument, styleTagId) {
    // Using a state factory so that this logic only runs once per render
    // Each FluentProvider can create its own style element during SSR as a slot
    // Moves all theme style elements to document head during render to avoid hydration errors.
    // Should be strict mode safe since the logic is idempotent.
    _react.useState(()=>{
        if (!targetDocument) {
            return;
        }
        const themeStyleElement = targetDocument.getElementById(styleTagId);
        if (themeStyleElement) {
            targetDocument.head.append(themeStyleElement);
        }
    });
} //# sourceMappingURL=useFluentProviderThemeStyleTag.js.map

//# sourceMappingURL=useFluentProviderThemeStyleTag.js.map