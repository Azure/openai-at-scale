"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useDataGrid_unstable", {
    enumerable: true,
    get: ()=>useDataGrid_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactTabster = require("@fluentui/react-tabster");
const _useTable = require("../Table/useTable");
const _hooks = require("../../hooks");
const _tableSelectionCell = require("../TableSelectionCell");
const _reactUtilities = require("@fluentui/react-utilities");
const _keyboardKeys = require("@fluentui/keyboard-keys");
const useDataGrid_unstable = (props, ref)=>{
    const { items , columns , focusMode ='cell' , selectionMode , onSortChange , onSelectionChange , defaultSortState , sortState , selectedItems , defaultSelectedItems , subtleSelection =false , selectionAppearance ='brand' , getRowId , resizableColumns , columnSizingOptions , onColumnResize  } = props;
    const navigable = focusMode !== 'none';
    const keyboardNavAttr = (0, _reactTabster.useArrowNavigationGroup)({
        axis: 'grid'
    });
    const tableState = (0, _hooks.useTableFeatures)({
        items,
        columns,
        getRowId
    }, [
        (0, _hooks.useTableSort)({
            defaultSortState,
            sortState,
            onSortChange
        }),
        (0, _hooks.useTableSelection)({
            defaultSelectedItems,
            selectedItems,
            onSelectionChange,
            selectionMode: selectionMode !== null && selectionMode !== void 0 ? selectionMode : 'multiselect'
        }),
        (0, _hooks.useTableColumnSizing_unstable)({
            onColumnResize,
            columnSizingOptions,
            // The selection cell is not part of the columns, therefore its width needs to be subtracted
            // from the container to make sure the columns don't overflow the table.
            containerWidthOffset: selectionMode ? -_tableSelectionCell.CELL_WIDTH : 0
        })
    ]);
    const innerRef = _react.useRef(null);
    const { findFirstFocusable , findLastFocusable  } = (0, _reactTabster.useFocusFinders)();
    const onKeyDown = (0, _reactUtilities.useEventCallback)((e)=>{
        var _props_onKeyDown;
        (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, e);
        if (!innerRef.current || !e.ctrlKey || e.defaultPrevented) {
            return;
        }
        if (e.key === _keyboardKeys.Home) {
            const firstRow = innerRef.current.querySelector('[role="row"]');
            if (firstRow) {
                var _findFirstFocusable;
                (_findFirstFocusable = findFirstFocusable(firstRow)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
            }
        }
        if (e.key === _keyboardKeys.End) {
            const rows = innerRef.current.querySelectorAll('[role="row"]');
            if (rows.length) {
                var _findLastFocusable;
                const lastRow = rows.item(rows.length - 1);
                (_findLastFocusable = findLastFocusable(lastRow)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
            }
        }
    });
    const baseTableState = (0, _useTable.useTable_unstable)({
        role: 'grid',
        as: 'div',
        noNativeElements: true,
        ...navigable && keyboardNavAttr,
        ...props,
        onKeyDown
    }, (0, _reactUtilities.useMergedRefs)(ref, tableState.tableRef, innerRef));
    return {
        ...baseTableState,
        focusMode,
        tableState,
        selectableRows: !!selectionMode,
        subtleSelection,
        selectionAppearance,
        resizableColumns
    };
}; //# sourceMappingURL=useDataGrid.js.map

//# sourceMappingURL=useDataGrid.js.map