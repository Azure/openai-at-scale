"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    defaultTableSelectionState: ()=>defaultTableSelectionState,
    useTableSelection: ()=>useTableSelection,
    useTableSelectionState: ()=>useTableSelectionState
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _selectionManager = require("./selectionManager");
const noop = ()=>undefined;
const defaultTableSelectionState = {
    allRowsSelected: false,
    clearRows: noop,
    deselectRow: noop,
    isRowSelected: ()=>false,
    selectRow: noop,
    selectedRows: /*#__PURE__*/ new Set(),
    someRowsSelected: false,
    toggleAllRows: noop,
    toggleRow: noop,
    selectionMode: 'multiselect'
};
function useTableSelection(options) {
    // False positive, these plugin hooks are intended to be run on every render
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (tableState)=>useTableSelectionState(tableState, options);
}
function useTableSelectionState(tableState, options) {
    const { items , getRowId  } = tableState;
    const { selectionMode , defaultSelectedItems , selectedItems , onSelectionChange  } = options;
    const [selected, setSelected] = (0, _reactUtilities.useControllableState)({
        initialState: new Set(),
        defaultState: _react.useMemo(()=>defaultSelectedItems && createSetFromIterable(defaultSelectedItems), [
            defaultSelectedItems
        ]),
        state: _react.useMemo(()=>selectedItems && createSetFromIterable(selectedItems), [
            selectedItems
        ])
    });
    const selectionManager = _react.useMemo(()=>{
        return (0, _selectionManager.createSelectionManager)(selectionMode, (e, newSelectedItems)=>{
            setSelected(()=>{
                onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(e, {
                    selectedItems: newSelectedItems
                });
                return newSelectedItems;
            });
        });
    }, [
        onSelectionChange,
        selectionMode,
        setSelected
    ]);
    const toggleAllRows = (0, _reactUtilities.useEventCallback)((e)=>{
        var _getRowId;
        selectionManager.toggleAllItems(e, items.map((item, i)=>{
            return (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i;
        }), selected);
    });
    const toggleRow = (0, _reactUtilities.useEventCallback)((e, rowId)=>selectionManager.toggleItem(e, rowId, selected));
    const deselectRow = (0, _reactUtilities.useEventCallback)((e, rowId)=>selectionManager.deselectItem(e, rowId, selected));
    const selectRow = (0, _reactUtilities.useEventCallback)((e, rowId)=>selectionManager.selectItem(e, rowId, selected));
    const isRowSelected = (rowId)=>selectionManager.isSelected(rowId, selected);
    return {
        ...tableState,
        selection: {
            selectionMode,
            someRowsSelected: selected.size > 0,
            allRowsSelected: selectionMode === 'single' ? selected.size > 0 : selected.size === items.length,
            selectedRows: selected,
            toggleRow,
            toggleAllRows,
            clearRows: selectionManager.clearItems,
            deselectRow,
            selectRow,
            isRowSelected
        }
    };
}
/**
 * Creates a set from a given iterable, in case the iterable is a set itself, returns the given set instead.
 */ function createSetFromIterable(iterable) {
    return iterable instanceof Set ? iterable : new Set(iterable);
} //# sourceMappingURL=useTableSelection.js.map

//# sourceMappingURL=useTableSelection.js.map