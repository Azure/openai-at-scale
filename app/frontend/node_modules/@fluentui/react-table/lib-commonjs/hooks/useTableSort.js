"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    defaultTableSortState: ()=>defaultTableSortState,
    useTableSort: ()=>useTableSort,
    useTableSortState: ()=>useTableSortState
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const noop = ()=>undefined;
const defaultTableSortState = {
    getSortDirection: ()=>'ascending',
    setColumnSort: noop,
    sort: (rows)=>[
            ...rows
        ],
    sortColumn: undefined,
    sortDirection: 'ascending',
    toggleColumnSort: noop
};
function useTableSort(options) {
    // False positive, these plugin hooks are intended to be run on every render
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (tableState)=>useTableSortState(tableState, options);
}
function useTableSortState(tableState, options) {
    const { columns  } = tableState;
    const { sortState , defaultSortState , onSortChange  } = options;
    const [sorted, setSorted] = (0, _reactUtilities.useControllableState)({
        initialState: {
            sortDirection: 'ascending',
            sortColumn: undefined
        },
        defaultState: defaultSortState,
        state: sortState
    });
    const { sortColumn , sortDirection  } = sorted;
    const toggleColumnSort = (e, columnId)=>{
        setSorted((s)=>{
            const newState = {
                ...s,
                sortColumn: columnId
            };
            if (s.sortColumn === columnId) {
                newState.sortDirection = s.sortDirection === 'ascending' ? 'descending' : 'ascending';
            } else {
                newState.sortDirection = 'ascending';
            }
            onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
            return newState;
        });
    };
    const setColumnSort = (e, nextSortColumn, nextSortDirection)=>{
        const newState = {
            sortColumn: nextSortColumn,
            sortDirection: nextSortDirection
        };
        onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
        setSorted(newState);
    };
    const sort = (rows)=>{
        return rows.slice().sort((a, b)=>{
            const sortColumnDef = columns.find((column)=>column.columnId === sortColumn);
            if (!(sortColumnDef === null || sortColumnDef === void 0 ? void 0 : sortColumnDef.compare)) {
                return 0;
            }
            const mod = sortDirection === 'ascending' ? 1 : -1;
            return sortColumnDef.compare(a.item, b.item) * mod;
        });
    };
    const getSortDirection = (columnId)=>{
        return sortColumn === columnId ? sortDirection : undefined;
    };
    return {
        ...tableState,
        sort: {
            sort,
            sortColumn,
            sortDirection,
            setColumnSort,
            toggleColumnSort,
            getSortDirection
        }
    };
} //# sourceMappingURL=useTableSort.js.map

//# sourceMappingURL=useTableSort.js.map