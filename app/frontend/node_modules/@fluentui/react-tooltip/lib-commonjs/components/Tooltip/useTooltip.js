"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTooltip_unstable", {
    enumerable: true,
    get: ()=>useTooltip_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactPositioning = require("@fluentui/react-positioning");
const _reactSharedContexts = require("@fluentui/react-shared-contexts");
const _reactUtilities = require("@fluentui/react-utilities");
const _constants = require("./private/constants");
const _keyboardKeys = require("@fluentui/keyboard-keys");
const useTooltip_unstable = (props)=>{
    var _child_props, _child_props1, _child_props2, _child_props3;
    const context = (0, _reactSharedContexts.useTooltipVisibility_unstable)();
    const isServerSideRender = (0, _reactUtilities.useIsSSR)();
    const { targetDocument  } = (0, _reactSharedContexts.useFluent_unstable)();
    const [setDelayTimeout, clearDelayTimeout] = (0, _reactUtilities.useTimeout)();
    const { appearance ='normal' , children , content , withArrow =false , positioning ='above' , onVisibleChange , relationship , showDelay =250 , hideDelay =250 , mountNode  } = props;
    const [visible, setVisibleInternal] = (0, _reactUtilities.useControllableState)({
        state: props.visible,
        initialState: false
    });
    const setVisible = _react.useCallback((newVisible, ev)=>{
        clearDelayTimeout();
        setVisibleInternal((oldVisible)=>{
            if (newVisible !== oldVisible) {
                onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, {
                    visible: newVisible
                });
            }
            return newVisible;
        });
    }, [
        clearDelayTimeout,
        setVisibleInternal,
        onVisibleChange
    ]);
    const state = {
        withArrow,
        positioning,
        showDelay,
        hideDelay,
        relationship,
        visible,
        shouldRenderTooltip: visible,
        appearance,
        mountNode,
        // Slots
        components: {
            content: 'div'
        },
        content: (0, _reactUtilities.resolveShorthand)(content, {
            defaultProps: {
                role: 'tooltip'
            },
            required: true
        })
    };
    state.content.id = (0, _reactUtilities.useId)('tooltip-', state.content.id);
    const positioningOptions = {
        enabled: state.visible,
        arrowPadding: 2 * _constants.tooltipBorderRadius,
        position: 'above',
        align: 'center',
        offset: 4,
        ...(0, _reactPositioning.resolvePositioningShorthand)(state.positioning)
    };
    if (state.withArrow) {
        positioningOptions.offset = (0, _reactPositioning.mergeArrowOffset)(positioningOptions.offset, _constants.arrowHeight);
    }
    const { targetRef , containerRef , arrowRef  } = (0, _reactPositioning.usePositioning)(positioningOptions);
    state.content.ref = (0, _reactUtilities.useMergedRefs)(state.content.ref, containerRef);
    state.arrowRef = arrowRef;
    // When this tooltip is visible, hide any other tooltips, and register it
    // as the visibleTooltip with the TooltipContext.
    // Also add a listener on document to hide the tooltip if Escape is pressed
    (0, _reactUtilities.useIsomorphicLayoutEffect)(()=>{
        if (visible) {
            var _context_visibleTooltip;
            const thisTooltip = {
                hide: ()=>setVisible(false)
            };
            (_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 ? void 0 : _context_visibleTooltip.hide();
            context.visibleTooltip = thisTooltip;
            const onDocumentKeyDown = (ev)=>{
                if (ev.key === _keyboardKeys.Escape) {
                    thisTooltip.hide();
                    // stop propagation to avoid conflicting with other elements that listen for `Escape`
                    // e,g: Dialog, Popover, Menu
                    ev.stopPropagation();
                }
            };
            targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('keydown', onDocumentKeyDown, {
                // As this event is added at targeted document,
                // we need to capture the event to be sure keydown handling from tooltip happens first
                capture: true
            });
            return ()=>{
                if (context.visibleTooltip === thisTooltip) {
                    context.visibleTooltip = undefined;
                }
                targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('keydown', onDocumentKeyDown, {
                    capture: true
                });
            };
        }
    }, [
        context,
        targetDocument,
        visible,
        setVisible
    ]);
    // The focused element gets a blur event when the document loses focus
    // (e.g. switching tabs in the browser), but we don't want to show the
    // tooltip again when the document gets focus back. Handle this case by
    // checking if the blurred element is still the document's activeElement.
    // See https://github.com/microsoft/fluentui/issues/13541
    const ignoreNextFocusEventRef = _react.useRef(false);
    // Listener for onPointerEnter and onFocus on the trigger element
    const onEnterTrigger = _react.useCallback((ev)=>{
        if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {
            ignoreNextFocusEventRef.current = false;
            return;
        }
        // Show immediately if another tooltip is already visible
        const delay = context.visibleTooltip ? 0 : state.showDelay;
        setDelayTimeout(()=>{
            setVisible(true, ev);
        }, delay);
        ev.persist(); // Persist the event since the setVisible call will happen asynchronously
    }, [
        setDelayTimeout,
        setVisible,
        state.showDelay,
        context
    ]);
    // Listener for onPointerLeave and onBlur on the trigger element
    const onLeaveTrigger = _react.useCallback((ev)=>{
        let delay = state.hideDelay;
        if (ev.type === 'blur') {
            // Hide immediately when losing focus
            delay = 0;
            ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
        }
        setDelayTimeout(()=>{
            setVisible(false, ev);
        }, delay);
        ev.persist(); // Persist the event since the setVisible call will happen asynchronously
    }, [
        setDelayTimeout,
        setVisible,
        state.hideDelay,
        targetDocument
    ]);
    // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.
    // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.
    state.content.onPointerEnter = (0, _reactUtilities.mergeCallbacks)(state.content.onPointerEnter, clearDelayTimeout);
    state.content.onPointerLeave = (0, _reactUtilities.mergeCallbacks)(state.content.onPointerLeave, onLeaveTrigger);
    state.content.onFocus = (0, _reactUtilities.mergeCallbacks)(state.content.onFocus, clearDelayTimeout);
    state.content.onBlur = (0, _reactUtilities.mergeCallbacks)(state.content.onBlur, onLeaveTrigger);
    const child = (0, _reactUtilities.getTriggerChild)(children);
    const triggerAriaProps = {};
    if (relationship === 'label') {
        // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.
        if (typeof state.content.children === 'string') {
            triggerAriaProps['aria-label'] = state.content.children;
        } else {
            triggerAriaProps['aria-labelledby'] = state.content.id;
            // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element
            state.shouldRenderTooltip = true;
        }
    } else if (relationship === 'description') {
        triggerAriaProps['aria-describedby'] = state.content.id;
        // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element
        state.shouldRenderTooltip = true;
    }
    // Don't render the Tooltip in SSR to avoid hydration errors
    if (isServerSideRender) {
        state.shouldRenderTooltip = false;
    }
    const childTargetRef = (0, _reactUtilities.useMergedRefs)(child === null || child === void 0 ? void 0 : child.ref, targetRef);
    // Apply the trigger props to the child, either by calling the render function, or cloning with the new props
    state.children = (0, _reactUtilities.applyTriggerPropsToChildren)(children, {
        ...triggerAriaProps,
        ...child === null || child === void 0 ? void 0 : child.props,
        // If the target prop is not provided, attach targetRef to the trigger element's ref prop
        ref: positioningOptions.target === undefined ? childTargetRef : child === null || child === void 0 ? void 0 : child.ref,
        onPointerEnter: (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)(child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.onPointerEnter, onEnterTrigger)),
        onPointerLeave: (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)(child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1.onPointerLeave, onLeaveTrigger)),
        onFocus: (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)(child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2.onFocus, onEnterTrigger)),
        onBlur: (0, _reactUtilities.useEventCallback)((0, _reactUtilities.mergeCallbacks)(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onBlur, onLeaveTrigger))
    });
    return state;
}; //# sourceMappingURL=useTooltip.js.map

//# sourceMappingURL=useTooltip.js.map