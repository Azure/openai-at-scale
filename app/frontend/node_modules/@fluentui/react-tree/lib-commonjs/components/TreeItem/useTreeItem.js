"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTreeItem_unstable", {
    enumerable: true,
    get: ()=>useTreeItem_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactIcons = require("@fluentui/react-icons");
const _reactSharedContexts = require("@fluentui/react-shared-contexts");
const _useTreeItemStyles = require("./useTreeItemStyles");
const _keyboardKeys = require("@fluentui/keyboard-keys");
const _reactPortal = require("@fluentui/react-portal");
const _index = require("../../contexts/index");
const _tokens = require("../../utils/tokens");
const useTreeItem_unstable = (props, ref)=>{
    const [children, subtreeChildren] = _react.Children.toArray(props.children);
    const contextLevel = (0, _index.useTreeContext_unstable)((ctx)=>ctx.level);
    const { content , subtree , expandIcon , leaf: isLeaf = subtreeChildren === undefined , actions , as ='div' , onClick , onKeyDown , ['aria-level']: level = contextLevel , ...rest } = props;
    const requestOpenChange = (0, _index.useTreeContext_unstable)((ctx)=>ctx.requestOpenChange);
    const requestNavigation = (0, _index.useTreeContext_unstable)((ctx)=>ctx.requestNavigation);
    const id = (0, _reactUtilities.useId)('fui-TreeItem-', props.id);
    const isBranch = !isLeaf;
    const open = (0, _index.useTreeContext_unstable)((ctx)=>isBranch && ctx.openItems.has(id));
    const { dir , targetDocument  } = (0, _reactSharedContexts.useFluent_unstable)();
    const expandIconRotation = open ? 90 : dir !== 'rtl' ? 0 : 180;
    const actionsRef = _react.useRef(null);
    const expandIconRef = _react.useRef(null);
    const subtreeRef = _react.useRef(null);
    const handleArrowRight = (event)=>{
        if (!open && isBranch) {
            return requestOpenChange({
                event,
                open: true,
                type: _tokens.treeDataTypes.arrowRight,
                target: event.currentTarget
            });
        }
        if (open && isBranch) {
            return requestNavigation({
                event,
                type: _tokens.treeDataTypes.arrowRight,
                target: event.currentTarget
            });
        }
    };
    const handleArrowLeft = (event)=>{
        if (open && isBranch) {
            return requestOpenChange({
                event,
                open: false,
                type: _tokens.treeDataTypes.arrowLeft,
                target: event.currentTarget
            });
        }
        if (!open && level > 1) {
            return requestNavigation({
                event,
                target: event.currentTarget,
                type: _tokens.treeDataTypes.arrowLeft
            });
        }
    };
    const handleEnter = (event)=>{
        requestOpenChange({
            event,
            open: isLeaf ? open : !open,
            type: _tokens.treeDataTypes.enter,
            target: event.currentTarget
        });
    };
    const handleClick = (0, _reactUtilities.useEventCallback)((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        const isEventFromActions = actionsRef.current && (0, _reactPortal.elementContains)(actionsRef.current, event.target);
        if (isEventFromActions) {
            return;
        }
        const isEventFromSubtree = subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target);
        if (isEventFromSubtree) {
            return;
        }
        const isFromExpandIcon = expandIconRef.current && (0, _reactPortal.elementContains)(expandIconRef.current, event.target);
        requestOpenChange({
            event,
            open: isLeaf ? open : !open,
            type: isFromExpandIcon ? _tokens.treeDataTypes.expandIconClick : _tokens.treeDataTypes.click,
            target: event.currentTarget
        });
        requestNavigation({
            event,
            target: event.currentTarget,
            type: _tokens.treeDataTypes.click
        });
    });
    const handleKeyDown = (0, _reactUtilities.useEventCallback)((event)=>{
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
        if (event.currentTarget !== event.target) {
            return;
        }
        if (event.isDefaultPrevented()) {
            return;
        }
        switch(event.key){
            case _keyboardKeys.Enter:
                return handleEnter(event);
            case _keyboardKeys.ArrowRight:
                return handleArrowRight(event);
            case _keyboardKeys.ArrowLeft:
                return handleArrowLeft(event);
            case _keyboardKeys.End:
                return requestNavigation({
                    event,
                    type: _tokens.treeDataTypes.end,
                    target: event.currentTarget
                });
            case _keyboardKeys.Home:
                return requestNavigation({
                    event,
                    type: _tokens.treeDataTypes.home,
                    target: event.currentTarget
                });
            case _keyboardKeys.ArrowUp:
                return requestNavigation({
                    event,
                    type: _tokens.treeDataTypes.arrowUp,
                    target: event.currentTarget
                });
            case _keyboardKeys.ArrowDown:
                return requestNavigation({
                    event,
                    type: _tokens.treeDataTypes.arrowDown,
                    target: event.currentTarget
                });
        }
        const isTypeAheadCharacter = event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey;
        if (isTypeAheadCharacter) {
            return requestNavigation({
                event,
                target: event.currentTarget,
                type: _tokens.treeDataTypes.typeAhead
            });
        }
    });
    const [isActionsVisible, setActionsVisible] = _react.useState(false);
    const showActions = (0, _reactUtilities.useEventCallback)((event)=>{
        const isEventFromSubtree = subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target);
        if (!isEventFromSubtree) {
            setActionsVisible(true);
        }
    });
    const hideActions = (0, _reactUtilities.useEventCallback)((event)=>{
        const isEventFromSubtree = subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target);
        if (!isEventFromSubtree) {
            setActionsVisible(false);
        }
    });
    // Listens to focusout event on the document to ensure treeitem actions visibility on portal scenarios
    // TODO: find a better way to ensure this behavior
    _react.useEffect(()=>{
        if (actionsRef.current) {
            const handleFocusOut = (event)=>{
                setActionsVisible((0, _reactPortal.elementContains)(actionsRef.current, event.relatedTarget));
            };
            targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('focusout', handleFocusOut, {
                passive: true
            });
            return ()=>{
                targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('focusout', handleFocusOut);
            };
        }
    }, [
        targetDocument
    ]);
    return {
        isLeaf,
        open,
        level,
        buttonSize: 'small',
        isActionsVisible: actions ? isActionsVisible : false,
        components: {
            content: 'div',
            root: 'div',
            expandIcon: 'span',
            actions: 'span',
            subtree: 'span'
        },
        subtree: (0, _reactUtilities.resolveShorthand)(subtree, {
            required: Boolean(subtreeChildren),
            defaultProps: {
                children: subtreeChildren,
                ref: (0, _reactUtilities.useMergedRefs)(subtreeRef, (0, _reactUtilities.isResolvedShorthand)(subtree) ? subtree.ref : undefined)
            }
        }),
        content: (0, _reactUtilities.resolveShorthand)(content, {
            required: true,
            defaultProps: {
                children
            }
        }),
        root: (0, _reactUtilities.getNativeElementProps)(as, {
            tabIndex: -1,
            ...rest,
            id,
            ref,
            children: null,
            'aria-level': level,
            'aria-expanded': isBranch ? open : undefined,
            role: 'treeitem',
            onClick: handleClick,
            onKeyDown: handleKeyDown,
            onMouseOver: actions ? showActions : undefined,
            onFocus: actions ? showActions : undefined,
            onMouseOut: actions ? hideActions : undefined,
            onBlur: actions ? hideActions : undefined
        }),
        expandIcon: (0, _reactUtilities.resolveShorthand)(expandIcon, {
            required: isBranch,
            defaultProps: {
                children: /*#__PURE__*/ _react.createElement(_reactIcons.ChevronRight12Regular, {
                    style: _useTreeItemStyles.expandIconInlineStyles[expandIconRotation]
                }),
                'aria-hidden': true,
                ref: (0, _reactUtilities.useMergedRefs)((0, _reactUtilities.isResolvedShorthand)(expandIcon) ? expandIcon.ref : undefined, expandIconRef)
            }
        }),
        actions: (0, _reactUtilities.resolveShorthand)(actions, {
            defaultProps: {
                ref: (0, _reactUtilities.useMergedRefs)((0, _reactUtilities.isResolvedShorthand)(actions) ? actions.ref : undefined, actionsRef)
            }
        })
    };
}; //# sourceMappingURL=useTreeItem.js.map

//# sourceMappingURL=useTreeItem.js.map