"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useOpenItemsState", {
    enumerable: true,
    get: ()=>useOpenItemsState
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _reactUtilities = require("@fluentui/react-utilities");
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _immutableSet = require("../utils/ImmutableSet");
function useOpenItemsState(props) {
    const [openItems, setOpenItems] = (0, _reactUtilities.useControllableState)({
        state: _react.useMemo(()=>props.openItems && (0, _immutableSet.createImmutableSet)(props.openItems), [
            props.openItems
        ]),
        defaultState: _react.useMemo(()=>props.defaultOpenItems && (0, _immutableSet.createImmutableSet)(props.defaultOpenItems), [
            props.defaultOpenItems
        ]),
        initialState: _immutableSet.emptyImmutableSet
    });
    const updateOpenItems = (0, _reactUtilities.useEventCallback)((data)=>setOpenItems((currentOpenItems)=>createNextOpenItems(data, currentOpenItems)));
    return [
        openItems,
        updateOpenItems
    ];
}
function createNextOpenItems(data, previousOpenItems) {
    const id = data.target.id;
    const previousOpenItemsHasId = previousOpenItems.has(id);
    if (data.open ? previousOpenItemsHasId : !previousOpenItemsHasId) {
        return previousOpenItems;
    }
    const nextOpenItems = (0, _immutableSet.createImmutableSet)(previousOpenItems);
    return data.open ? nextOpenItems.add(id) : nextOpenItems.delete(id);
} //# sourceMappingURL=useOpenItemsState.js.map

//# sourceMappingURL=useOpenItemsState.js.map