/**
 * creates a list of flat tree items
 * and provides a map to access each item by id
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createFlatTreeItems: ()=>createFlatTreeItems,
    flatTreeRootId: ()=>flatTreeRootId,
    VisibleFlatTreeItemGenerator: ()=>VisibleFlatTreeItemGenerator
});
function createFlatTreeItems(flatTreeItemProps) {
    const root = createFlatTreeRootItem();
    const itemsPerId = new Map([
        [
            flatTreeRootId,
            root
        ]
    ]);
    const items = [];
    for(let index = 0; index < flatTreeItemProps.length; index++){
        const { parentId =flatTreeRootId , ...treeItemProps } = flatTreeItemProps[index];
        const nextItemProps = flatTreeItemProps[index + 1];
        const currentParent = itemsPerId.get(parentId);
        if (!currentParent) {
            if (process.env.NODE_ENV === 'development') {
                // eslint-disable-next-line no-console
                console.error(`useFlatTree: item ${flatTreeItemProps[index].id} is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized`);
            }
            break;
        }
        const isLeaf = (nextItemProps === null || nextItemProps === void 0 ? void 0 : nextItemProps.parentId) !== treeItemProps.id;
        var _currentParent_level;
        const currentLevel = ((_currentParent_level = currentParent.level) !== null && _currentParent_level !== void 0 ? _currentParent_level : 0) + 1;
        const currentChildrenSize = ++currentParent.childrenSize;
        const flatTreeItem = {
            id: treeItemProps.id,
            getTreeItemProps: ()=>({
                    ...treeItemProps,
                    'aria-level': currentLevel,
                    'aria-posinset': currentChildrenSize,
                    'aria-setsize': currentParent.childrenSize,
                    leaf: isLeaf
                }),
            level: currentLevel,
            parentId,
            childrenSize: 0,
            index: -1
        };
        itemsPerId.set(flatTreeItem.id, flatTreeItem);
        items.push(flatTreeItem);
    }
    return {
        root,
        size: items.length,
        getByIndex: (index)=>items[index],
        get: (id)=>itemsPerId.get(id),
        set: (id, value)=>itemsPerId.set(id, value)
    };
}
const flatTreeRootId = '__fuiFlatTreeRoot';
function createFlatTreeRootItem() {
    return {
        id: flatTreeRootId,
        getTreeItemProps: ()=>{
            if (process.env.NODE_ENV !== 'production') {
                // eslint-disable-next-line no-console
                console.error('useFlatTree: internal error, trying to access treeitem props from invalid root element');
            }
            return {
                id: flatTreeRootId,
                'aria-setsize': -1,
                'aria-level': -1,
                'aria-posinset': -1,
                leaf: true
            };
        },
        childrenSize: 0,
        get index () {
            if (process.env.NODE_ENV !== 'production') {
                // eslint-disable-next-line no-console
                console.error('useFlatTree: internal error, trying to access treeitem props from invalid root element');
            }
            return -1;
        },
        level: 0
    };
}
function* VisibleFlatTreeItemGenerator(openItems, flatTreeItems) {
    for(let index = 0, visibleIndex = 0; index < flatTreeItems.size; index++){
        const item = flatTreeItems.getByIndex(index);
        var _flatTreeItems_get;
        const parent = item.parentId ? (_flatTreeItems_get = flatTreeItems.get(item.parentId)) !== null && _flatTreeItems_get !== void 0 ? _flatTreeItems_get : flatTreeItems.root : flatTreeItems.root;
        if (isItemVisible(item, openItems, flatTreeItems)) {
            item.index = visibleIndex++;
            yield item;
        } else {
            index += parent.childrenSize - 1 + item.childrenSize;
        }
    }
}
function isItemVisible(item, openItems, flatTreeItems) {
    if (item.level === 1) {
        return true;
    }
    while(item.parentId && item.parentId !== flatTreeItems.root.id){
        if (!openItems.has(item.parentId)) {
            return false;
        }
        const parent = flatTreeItems.get(item.parentId);
        if (!parent) {
            return false;
        }
        item = parent;
    }
    return true;
} //# sourceMappingURL=createFlatTreeItems.js.map

//# sourceMappingURL=createFlatTreeItems.js.map