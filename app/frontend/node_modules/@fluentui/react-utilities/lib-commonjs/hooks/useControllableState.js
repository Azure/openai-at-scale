"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useControllableState", {
    enumerable: true,
    get: ()=>useControllableState
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
function isFactoryDispatch(newState) {
    return typeof newState === 'function';
}
const useControllableState = (options)=>{
    const isControlled = useIsControlled(options.state);
    const initialState = typeof options.defaultState === 'undefined' ? options.initialState : options.defaultState;
    const [internalState, setInternalState] = _react.useState(initialState);
    const state = isControlled ? options.state : internalState;
    const stateRef = _react.useRef(state);
    _react.useEffect(()=>{
        stateRef.current = state;
    }, [
        state
    ]);
    // To match the behavior of the setter returned by React.useState, this callback's identity
    // should never change. This means it MUST NOT directly reference variables that can change.
    const setState = _react.useCallback((newState)=>{
        // React dispatch can use a factory
        // https://reactjs.org/docs/hooks-reference.html#functional-updates
        if (isFactoryDispatch(newState)) {
            stateRef.current = newState(stateRef.current);
        } else {
            stateRef.current = newState;
        }
        setInternalState(stateRef.current);
    }, []);
    return [
        state,
        setState
    ];
};
/**
 * Helper hook to handle previous comparison of controlled/uncontrolled
 * Prints an error when isControlled value switches between subsequent renders
 * @returns - whether the value is controlled
 */ const useIsControlled = (controlledValue)=>{
    const [isControlled] = _react.useState(()=>controlledValue !== undefined);
    if (process.env.NODE_ENV !== 'production') {
        // We don't want these warnings in production even though it is against native behaviour
        // eslint-disable-next-line react-hooks/rules-of-hooks
        _react.useEffect(()=>{
            if (isControlled !== (controlledValue !== undefined)) {
                const error = new Error();
                const controlWarning = isControlled ? 'a controlled value to be uncontrolled' : 'an uncontrolled value to be controlled';
                const undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined';
                // eslint-disable-next-line no-console
                console.error([
                    // Default react error
                    'A component is changing ' + controlWarning + '. This is likely caused by the value',
                    'changing from ' + undefinedWarning + ' value, which should not happen.',
                    'Decide between using a controlled or uncontrolled input element for the lifetime of the component.',
                    'More info: https://reactjs.org/link/controlled-components',
                    error.stack
                ].join(' '));
            }
        }, [
            isControlled,
            controlledValue
        ]);
    }
    return isControlled;
}; //# sourceMappingURL=useControllableState.js.map

//# sourceMappingURL=useControllableState.js.map