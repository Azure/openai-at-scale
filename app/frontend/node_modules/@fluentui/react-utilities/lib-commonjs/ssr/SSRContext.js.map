{"version":3,"sources":["../../lib/ssr/SSRContext.js"],"sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './canUseDOM';\n/**\n * Default context value to use in case there is no SSRProvider. This is fine for client-only apps.\n *\n * @internal\n */\nexport const defaultSSRContextValue = {\n  current: 0\n};\nexport const SSRContext = /*#__PURE__*/React.createContext(undefined);\n/**\n * @internal\n */\nexport function useSSRContext() {\n  var _React_useContext;\n  return (_React_useContext = React.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;\n}\n/**\n * When using SSR with Fluent UI, applications must be wrapped in an SSRProvider. This ensures that auto generated ids\n * are consistent between the client and server.\n *\n * @public\n */\nexport const SSRProvider = props => {\n  const [value] = React.useState(() => ({\n    current: 0\n  }));\n  return /*#__PURE__*/React.createElement(SSRContext.Provider, {\n    value: value\n  }, props.children);\n};\n/**\n * Returns whether the component is currently being server side rendered or hydrated on the client. Can be used to delay\n * browser-specific rendering until after hydration. May cause re-renders on a client when is used within SSRProvider.\n */\nexport function useIsSSR() {\n  const isInSSRContext = useSSRContext() !== defaultSSRContextValue;\n  const [isSSR, setIsSSR] = React.useState(isInSSRContext);\n  // If we are rendering in a non-DOM environment, and there's no SSRProvider, provide a warning to hint to the\n  // developer to add one.\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isInSSRContext && !canUseDOM()) {\n      // eslint-disable-next-line no-console\n      console.error(['@fluentui/react-components: ', 'When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are ' + 'generated between the client and server.', '\\n', '\\n', 'Check documentation at https://aka.ms/fluentui-ssr'].join(''));\n    }\n  }\n  // If on the client, and the component was initially server rendered, then schedule a layout effect to update the\n  // component after hydration.\n  if (canUseDOM() && isInSSRContext) {\n    // This if statement technically breaks the rules of hooks, but is safe because the condition never changes after\n    // mounting.\n    // eslint-disable-next-line\n    React.useLayoutEffect(() => {\n      setIsSSR(false);\n    }, []);\n  }\n  return isSSR;\n}\n//# sourceMappingURL=SSRContext.js.map"],"names":["defaultSSRContextValue","SSRContext","useSSRContext","SSRProvider","useIsSSR","current","React","createContext","undefined","_React_useContext","useContext","props","value","useState","createElement","Provider","children","isInSSRContext","isSSR","setIsSSR","process","env","NODE_ENV","canUseDOM","console","error","join","useLayoutEffect"],"mappings":";;;;;;;;;;;IAOaA,sBAAsB,MAAtBA;IAGAC,UAAU,MAAVA;IAIGC,aAAa,MAAbA;IAUHC,WAAW,MAAXA;IAYGC,QAAQ,MAARA;;;6DApCO;2BACG;AAMnB,MAAMJ,yBAAyB;IACpCK,SAAS;AACX;AACO,MAAMJ,aAAa,WAAW,GAAEK,OAAMC,aAAa,CAACC;AAIpD,SAASN,gBAAgB;IAC9B,IAAIO;IACJ,OAAO,AAACA,CAAAA,oBAAoBH,OAAMI,UAAU,CAACT,WAAU,MAAO,IAAI,IAAIQ,sBAAsB,KAAK,IAAIA,oBAAoBT,sBAAsB;AACjJ;AAOO,MAAMG,cAAcQ,CAAAA,QAAS;IAClC,MAAM,CAACC,MAAM,GAAGN,OAAMO,QAAQ,CAAC,IAAO,CAAA;YACpCR,SAAS;QACX,CAAA;IACA,OAAO,WAAW,GAAEC,OAAMQ,aAAa,CAACb,WAAWc,QAAQ,EAAE;QAC3DH,OAAOA;IACT,GAAGD,MAAMK,QAAQ;AACnB;AAKO,SAASZ,WAAW;IACzB,MAAMa,iBAAiBf,oBAAoBF;IAC3C,MAAM,CAACkB,OAAOC,SAAS,GAAGb,OAAMO,QAAQ,CAACI;IACzC,6GAA6G;IAC7G,wBAAwB;IACxB,IAAIG,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;QACzC,IAAI,CAACL,kBAAkB,CAACM,IAAAA,oBAAS,KAAI;YACnC,sCAAsC;YACtCC,QAAQC,KAAK,CAAC;gBAAC;gBAAgC,4GAA4G;gBAA4C;gBAAM;gBAAM;aAAqD,CAACC,IAAI,CAAC;QAChR,CAAC;IACH,CAAC;IACD,iHAAiH;IACjH,6BAA6B;IAC7B,IAAIH,IAAAA,oBAAS,OAAMN,gBAAgB;QACjC,iHAAiH;QACjH,YAAY;QACZ,2BAA2B;QAC3BX,OAAMqB,eAAe,CAAC,IAAM;YAC1BR,SAAS,KAAK;QAChB,GAAG,EAAE;IACP,CAAC;IACD,OAAOD;AACT,EACA,sCAAsC"}