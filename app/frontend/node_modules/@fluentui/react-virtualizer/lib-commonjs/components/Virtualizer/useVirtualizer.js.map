{"version":3,"sources":["../../../lib/components/Virtualizer/useVirtualizer.js"],"sourcesContent":["import { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport { useEffect, useRef, useState, useCallback, useReducer } from 'react';\nimport { resolveShorthand } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\nexport function useVirtualizer_unstable(props) {\n  const {\n    itemSize,\n    numItems,\n    virtualizerLength,\n    children: renderChild,\n    getItemSize,\n    bufferItems = Math.round(virtualizerLength / 4.0),\n    bufferSize = Math.floor(bufferItems / 2.0) * itemSize,\n    scrollViewRef,\n    axis = 'vertical',\n    reversed = false,\n    onUpdateIndex,\n    onCalculateIndex\n  } = props;\n  // Tracks the initial item to start virtualizer at, -1 implies first render cycle\n  const [virtualizerStartIndex, setVirtualizerStartIndex] = useState(-1);\n  // Store ref to before padding element\n  const beforeElementRef = useRef(null);\n  // Store ref to before padding element\n  const afterElementRef = useRef(null);\n  // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n  const childSizes = useRef(new Array(getItemSize ? numItems : 0));\n  /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */\n  const childProgressiveSizes = useRef(new Array(getItemSize ? numItems : 0));\n  // The internal tracking REF for child array (updates often).\n  const childArray = useRef(new Array(virtualizerLength));\n  // We want to be methodical about updating the render with child reference array\n  const forceUpdate = useReducer(() => ({}), {})[1];\n  const horizontal = axis === 'horizontal';\n  const populateSizeArrays = () => {\n    if (!getItemSize) {\n      // Static sizes, never mind!\n      return;\n    }\n    if (numItems !== childSizes.current.length) {\n      childSizes.current = new Array(numItems);\n    }\n    if (numItems !== childProgressiveSizes.current.length) {\n      childProgressiveSizes.current = new Array(numItems);\n    }\n    for (let index = 0; index < numItems; index++) {\n      childSizes.current[index] = getItemSize(index);\n      if (index === 0) {\n        childProgressiveSizes.current[index] = childSizes.current[index];\n      } else {\n        childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n      }\n    }\n  };\n  const batchUpdateNewIndex = index => {\n    // Local updates\n    onUpdateIndex === null || onUpdateIndex === void 0 ? void 0 : onUpdateIndex(index, virtualizerStartIndex);\n    updateChildRows(index);\n    updateCurrentItemSizes(index);\n    // State setters\n    setVirtualizerStartIndex(index);\n  };\n  // Observe intersections of virtualized components\n  const {\n    setObserverList\n  } = useIntersectionObserver((entries, observer) => {\n    /* Sanity check - do we even need virtualization? */if (virtualizerLength > numItems) {\n      if (virtualizerStartIndex !== 0) {\n        batchUpdateNewIndex(0);\n      }\n      // No-op\n      return;\n    }\n    /* IO initiates this function when needed (bookend entering view) */\n    let measurementPos = 0;\n    let bufferCount = bufferItems;\n    // Grab latest entry that is intersecting\n    const latestEntry = entries.length === 1 ? entries[0] : entries.sort((entry1, entry2) => entry2.time - entry1.time).find(entry => {\n      return entry.intersectionRatio > 0;\n    });\n    if (!latestEntry) {\n      // If we don't find an intersecting area, ignore for now.\n      return;\n    }\n    if (latestEntry.target === afterElementRef.current) {\n      // We need to inverse the buffer count\n      bufferCount = virtualizerLength - bufferItems;\n      measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n      if (!horizontal) {\n        if (reversed) {\n          // Scrolling 'up' and hit the after element below\n          measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n        } else if (latestEntry.boundingClientRect.top < 0) {\n          // Scrolling 'down' and hit the after element above top: 0\n          measurementPos -= latestEntry.boundingClientRect.top;\n        }\n      } else {\n        if (reversed) {\n          // Scrolling 'left' and hit the after element\n          measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n        } else if (latestEntry.boundingClientRect.left < 0) {\n          // Scrolling 'right' and hit the after element\n          measurementPos -= latestEntry.boundingClientRect.left;\n        }\n      }\n    } else if (latestEntry.target === beforeElementRef.current) {\n      measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n      if (!horizontal) {\n        if (!reversed) {\n          measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n        } else if (latestEntry.boundingClientRect.top < 0) {\n          // Scrolling 'down' in reverse order and hit the before element above top: 0\n          measurementPos -= latestEntry.boundingClientRect.top;\n        }\n      } else {\n        if (!reversed) {\n          measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n        } else if (latestEntry.boundingClientRect.left < 0) {\n          // Scrolling 'left' and hit before element\n          measurementPos -= latestEntry.boundingClientRect.left;\n        }\n      }\n    }\n    if (reversed) {\n      // We're reversed, up is down, left is right, invert the scroll measure.\n      measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n    }\n    // For now lets use hardcoded size to assess current element to paginate on\n    const startIndex = getIndexFromScrollPosition(measurementPos);\n    let bufferedIndex = Math.max(startIndex - bufferCount, 0);\n    if (onCalculateIndex) {\n      // User has chance to intervene/customize prior to render\n      // They may want to normalize this value.\n      bufferedIndex = onCalculateIndex(bufferedIndex);\n    }\n    // Safety limits\n    const maxIndex = Math.max(numItems - virtualizerLength, 0);\n    const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n    if (virtualizerStartIndex !== newStartIndex) {\n      // We flush sync this and perform an immediate state update\n      // due to virtualizerStartIndex invalidation.\n      flushSync(() => {\n        batchUpdateNewIndex(newStartIndex);\n      });\n    }\n  }, {\n    root: scrollViewRef ? scrollViewRef === null || scrollViewRef === void 0 ? void 0 : scrollViewRef.current : null,\n    rootMargin: '0px',\n    threshold: 0\n  });\n  const findIndexRecursive = (scrollPos, lowIndex, highIndex) => {\n    if (lowIndex > highIndex) {\n      // We shouldn't get here - but no-op the index if we do.\n      return virtualizerStartIndex;\n    }\n    const midpoint = Math.floor((lowIndex + highIndex) / 2);\n    const iBefore = Math.max(midpoint - 1, 0);\n    const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n    const indexValue = childProgressiveSizes.current[midpoint];\n    const afterIndexValue = childProgressiveSizes.current[iAfter];\n    const beforeIndexValue = childProgressiveSizes.current[iBefore];\n    if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n      /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */\n      return midpoint;\n    }\n    if (indexValue > scrollPos) {\n      return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n    } else {\n      return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n    }\n  };\n  const getIndexFromSizeArray = scrollPos => {\n    /* Quick searches our progressive height array */if (scrollPos === 0 || childProgressiveSizes.current.length === 0 || scrollPos <= childProgressiveSizes.current[0]) {\n      // Check start\n      return 0;\n    }\n    if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n      // Check end\n      return childProgressiveSizes.current.length - 1;\n    }\n    return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n  };\n  const getIndexFromScrollPosition = scrollPos => {\n    if (!getItemSize) {\n      return Math.round(scrollPos / itemSize);\n    }\n    return getIndexFromSizeArray(scrollPos);\n  };\n  const calculateTotalSize = () => {\n    if (!getItemSize) {\n      return itemSize * numItems;\n    }\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1];\n  };\n  const calculateBefore = () => {\n    if (!getItemSize) {\n      // The missing items from before virtualization starts height\n      return virtualizerStartIndex * itemSize;\n    }\n    if (virtualizerStartIndex <= 0) {\n      return 0;\n    }\n    // Time for custom size calcs\n    return childProgressiveSizes.current[virtualizerStartIndex - 1];\n  };\n  const calculateAfter = () => {\n    if (numItems === 0) {\n      return 0;\n    }\n    const lastItemIndex = Math.min(virtualizerStartIndex + virtualizerLength, numItems - 1);\n    if (!getItemSize) {\n      // The missing items from after virtualization ends height\n      const remainingItems = numItems - lastItemIndex - 1;\n      return remainingItems * itemSize;\n    }\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex];\n  };\n  const updateChildRows = useCallback(newIndex => {\n    if (numItems === 0) {\n      /* Nothing to virtualize */return [];\n    }\n    if (childArray.current.length !== numItems) {\n      childArray.current = new Array(virtualizerLength);\n    }\n    const actualIndex = Math.max(newIndex, 0);\n    const end = Math.min(actualIndex + virtualizerLength, numItems);\n    for (let i = actualIndex; i < end; i++) {\n      childArray.current[i - actualIndex] = renderChild(i);\n    }\n  }, [numItems, renderChild, virtualizerLength]);\n  const setBeforeRef = useCallback(element => {\n    if (!element || beforeElementRef.current === element) {\n      return;\n    }\n    beforeElementRef.current = element;\n    const newList = [];\n    newList.push(beforeElementRef.current);\n    if (afterElementRef.current) {\n      newList.push(afterElementRef.current);\n    }\n    // Ensure we update array if before element changed\n    setObserverList(newList);\n  }, [setObserverList]);\n  const setAfterRef = useCallback(element => {\n    if (!element || afterElementRef.current === element) {\n      return;\n    }\n    afterElementRef.current = element;\n    const newList = [];\n    if (beforeElementRef.current) {\n      newList.push(beforeElementRef.current);\n    }\n    newList.push(afterElementRef.current);\n    // Ensure we update array if after element changed\n    setObserverList(newList);\n  }, [setObserverList]);\n  const updateCurrentItemSizes = newIndex => {\n    if (!getItemSize) {\n      // Static sizes, not required.\n      return;\n    }\n    // We should always call our size function on index change (only for the items that will be rendered)\n    // This ensures we request the latest data for incoming items in case sizing has changed.\n    const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n    const startIndex = Math.max(newIndex, 0);\n    let didUpdate = false;\n    for (let i = startIndex; i < endIndex; i++) {\n      const newSize = getItemSize(i);\n      if (newSize !== childSizes.current[i]) {\n        childSizes.current[i] = newSize;\n        didUpdate = true;\n      }\n    }\n    if (didUpdate) {\n      // Update our progressive size array\n      for (let i = startIndex; i < numItems; i++) {\n        const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n        childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n      }\n    }\n  };\n  // Initialize the size array before first render.\n  const hasInitialized = useRef(false);\n  const initializeSizeArray = () => {\n    if (hasInitialized.current === false) {\n      hasInitialized.current = true;\n      populateSizeArrays();\n    }\n  };\n  // Initialization on mount - update array index to 0 (ready state).\n  // Only fire on mount (no deps).\n  useEffect(() => {\n    if (virtualizerStartIndex < 0) {\n      batchUpdateNewIndex(0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  // If the user passes in an updated renderChild function - update current children\n  useEffect(() => {\n    if (virtualizerStartIndex >= 0) {\n      updateChildRows(virtualizerStartIndex);\n      forceUpdate();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderChild, updateChildRows]);\n  // Ensure we have run through and updated the whole size list array at least once.\n  initializeSizeArray();\n  if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n    // Child length mismatch, repopulate size arrays.\n    populateSizeArrays();\n  }\n  // Ensure we recalc if virtualizer length changes\n  const maxCompare = Math.min(virtualizerLength, numItems);\n  if (childArray.current.length !== maxCompare && virtualizerStartIndex + childArray.current.length < numItems) {\n    updateChildRows(virtualizerStartIndex);\n  }\n  const isFullyInitialized = hasInitialized.current && virtualizerStartIndex >= 0;\n  return {\n    components: {\n      before: 'div',\n      after: 'div',\n      beforeContainer: 'div',\n      afterContainer: 'div'\n    },\n    virtualizedChildren: childArray.current,\n    before: resolveShorthand(props.before, {\n      required: true,\n      defaultProps: {\n        ref: setBeforeRef,\n        role: 'none'\n      }\n    }),\n    after: resolveShorthand(props.after, {\n      required: true,\n      defaultProps: {\n        ref: setAfterRef,\n        role: 'none'\n      }\n    }),\n    beforeContainer: resolveShorthand(props.beforeContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none'\n      }\n    }),\n    afterContainer: resolveShorthand(props.afterContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none'\n      }\n    }),\n    beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n    afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n    totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n    virtualizerStartIndex,\n    axis,\n    bufferSize,\n    reversed\n  };\n}\n//# sourceMappingURL=useVirtualizer.js.map"],"names":["useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","scrollViewRef","axis","reversed","onUpdateIndex","onCalculateIndex","virtualizerStartIndex","setVirtualizerStartIndex","useState","beforeElementRef","useRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","useReducer","horizontal","populateSizeArrays","current","length","index","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","useIntersectionObserver","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","flushSync","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","lastItemIndex","remainingItems","useCallback","newIndex","actualIndex","end","i","setBeforeRef","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","useEffect","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","resolveShorthand","required","defaultProps","ref","role","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight"],"mappings":"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"}