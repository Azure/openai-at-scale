"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useIntersectionObserver", {
    enumerable: true,
    get: ()=>useIntersectionObserver
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const { useState , useRef  } = _react;
const useIntersectionObserver = (callback, options)=>{
    const observer = useRef();
    const [observerList, setObserverList] = useState();
    const [observerInit, setObserverInit] = useState(options);
    // Observer elements in passed in list and clean up previous list
    // This effect is only triggered when observerList is updated
    (0, _reactUtilities.useIsomorphicLayoutEffect)(()=>{
        observer.current = new IntersectionObserver(callback, observerInit);
        // If we have an instance of IO and a list with elements, observer the elements
        if (observer.current && observerList && observerList.length > 0) {
            observerList.forEach((element)=>{
                var _observer_current;
                (_observer_current = observer.current) === null || _observer_current === void 0 ? void 0 : _observer_current.observe(element);
            });
        }
        // clean up previous elements being listened to
        return ()=>{
            if (observer.current) {
                observer.current.disconnect();
            }
        };
    }, [
        observerList,
        observerInit,
        callback
    ]);
    return {
        setObserverList,
        setObserverInit,
        observer
    };
}; //# sourceMappingURL=useIntersectionObserver.js.map

//# sourceMappingURL=useIntersectionObserver.js.map