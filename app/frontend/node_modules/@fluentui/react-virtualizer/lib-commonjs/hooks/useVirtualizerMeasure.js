"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useStaticVirtualizerMeasure", {
    enumerable: true,
    get: ()=>useStaticVirtualizerMeasure
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _debounce = require("../utilities/debounce");
const useStaticVirtualizerMeasure = (virtualizerProps)=>{
    const { defaultItemSize , direction ='vertical'  } = virtualizerProps;
    const [state, setState] = _react.useState({
        virtualizerLength: 0,
        bufferSize: 0,
        bufferItems: 0
    });
    const { virtualizerLength , bufferItems , bufferSize  } = state;
    // The ref the user sets on their scrollView - Defaults to document.body to ensure no null on init
    const container = _react.useRef(null);
    const resizeCallback = ()=>{
        if (!container.current) {
            return;
        }
        const containerSize = direction === 'vertical' ? container.current.getBoundingClientRect().height : container.current.getBoundingClientRect().width;
        /*
    * Number of items required to cover viewport.
    */ const length = Math.ceil(containerSize / defaultItemSize + 1);
        /*
    * Number of items to append at each end, i.e. 'preload' each side before entering view.
    */ const newBufferItems = Math.max(Math.floor(length / 4), 2);
        /*
    * This is how far we deviate into the bufferItems to detect a redraw.
    */ const newBufferSize = Math.max(Math.floor(length / 8 * defaultItemSize), 1);
        const totalLength = length + newBufferItems * 2 + 1;
        setState({
            virtualizerLength: totalLength,
            bufferItems: newBufferItems,
            bufferSize: newBufferSize
        });
    };
    // the handler for resize observer
    const handleResize = (0, _debounce.debounce)(resizeCallback);
    // Keep the reference of ResizeObserver in the state, as it should live through renders
    const [resizeObserver] = _react.useState((0, _reactUtilities.canUseDOM)() ? new ResizeObserver(handleResize) : undefined);
    _react.useEffect(()=>{
        return ()=>{
            resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const scrollRef = _react.useCallback((el)=>{
        if (container.current !== el) {
            if (container.current) {
                resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.unobserve(container.current);
            }
            container.current = el;
            if (container.current) {
                resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(container.current);
            }
        }
    }, [
        resizeObserver
    ]);
    return {
        virtualizerLength,
        bufferItems,
        bufferSize,
        scrollRef
    };
}; //# sourceMappingURL=useVirtualizerMeasure.js.map

//# sourceMappingURL=useVirtualizerMeasure.js.map