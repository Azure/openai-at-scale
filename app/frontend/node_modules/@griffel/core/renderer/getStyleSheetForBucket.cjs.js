'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var constants = require('../constants.cjs.js');
var createIsomorphicStyleSheet = require('./createIsomorphicStyleSheet.cjs.js');

/**
 * Ordered style buckets using their short pseudo name.
 *
 * @internal
 */
const styleBucketOrdering = [
// reset styles
'r',
// catch-all
'd',
// link
'l',
// visited
'v',
// focus-within
'w',
// focus
'f',
// focus-visible
'i',
// hover
'h',
// active
'a',
// keyframes
'k',
// at-rules
't',
// @media rules
'm'];
// avoid repeatedly calling `indexOf`to determine order during new insertions
const styleBucketOrderingMap = /*#__PURE__*/styleBucketOrdering.reduce((acc, cur, j) => {
  acc[cur] = j;
  return acc;
}, {});
/**
 * Lazily adds a `<style>` bucket to the `<head>`. This will ensure that the style buckets are ordered.
 */
function getStyleSheetForBucket(bucketName, targetDocument, insertionPoint, renderer, metadata = {}) {
  const isMediaBucket = bucketName === 'm';
  const stylesheetKey = isMediaBucket ? bucketName + metadata['m'] : bucketName;
  if (!renderer.stylesheets[stylesheetKey]) {
    const tag = targetDocument && targetDocument.createElement('style');
    const stylesheet = createIsomorphicStyleSheet.createIsomorphicStyleSheet(tag, bucketName, {
      ...renderer.styleElementAttributes,
      ...(isMediaBucket && {
        media: metadata['m']
      })
    });
    renderer.stylesheets[stylesheetKey] = stylesheet;
    if (targetDocument && tag) {
      targetDocument.head.insertBefore(tag, findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata));
    }
  }
  return renderer.stylesheets[stylesheetKey];
}
/**
 * Finds an element before which the new bucket style element should be inserted following the bucket sort order.
 *
 * @param targetDocument - A document
 * @param insertionPoint - An element that will be used as an initial insertion point
 * @param targetBucket - The bucket that should be inserted to DOM
 * @param renderer - Griffel renderer
 * @param metadata - metadata for CSS rule
 * @returns - Smallest style element with greater sort order than the current bucket
 */
function findInsertionPoint(targetDocument, insertionPoint, targetBucket, renderer, metadata) {
  const targetOrder = styleBucketOrderingMap[targetBucket];
  // Similar to javascript sort comparators where
  // a positive value is increasing sort order
  // a negative value is decreasing sort order
  let comparer = el => targetOrder - styleBucketOrderingMap[el.getAttribute(constants.DATA_BUCKET_ATTR)];
  let styleElements = targetDocument.head.querySelectorAll(`[${constants.DATA_BUCKET_ATTR}]`);
  if (targetBucket === 'm' && metadata) {
    const mediaElements = targetDocument.head.querySelectorAll(`[${constants.DATA_BUCKET_ATTR}="${targetBucket}"]`);
    // only reduce the scope of the search and change comparer
    // if there are other media buckets already on the page
    if (mediaElements.length) {
      styleElements = mediaElements;
      comparer = el => renderer.compareMediaQueries(metadata['m'], el.media);
    }
  }
  const length = styleElements.length;
  let index = length - 1;
  while (index >= 0) {
    const styleElement = styleElements.item(index);
    if (comparer(styleElement) > 0) {
      return styleElement.nextSibling;
    }
    index--;
  }
  if (length > 0) {
    return styleElements.item(0);
  }
  return insertionPoint ? insertionPoint.nextSibling : null;
}

exports.getStyleSheetForBucket = getStyleSheetForBucket;
exports.styleBucketOrdering = styleBucketOrdering;
//# sourceMappingURL=getStyleSheetForBucket.cjs.js.map
