{"version":3,"file":"rehydrateRendererCache.esm.js","sources":["../../../../packages/core/src/renderer/rehydrateRendererCache.ts"],"sourcesContent":["import { GriffelRenderer, StyleBucketName } from '../types';\nimport { createIsomorphicStyleSheetFromElement } from './createIsomorphicStyleSheet';\nimport { isDevToolsEnabled, debugData } from '../devtools';\n\n// Regexps to extract names of classes and animations\n// https://github.com/styletron/styletron/blob/e0fcae826744eb00ce679ac613a1b10d44256660/packages/styletron-engine-atomic/src/client/client.js#L8\nconst KEYFRAMES_HYDRATOR = /@(-webkit-)?keyframes ([^{]+){((?:(?:from|to|(?:\\d+\\.?\\d*%))\\{(?:[^}])*})*)}/g;\nconst AT_RULES_HYDRATOR = /@(media|supports|layer)[^{]+\\{([\\s\\S]+?})\\s*}/g;\nconst STYLES_HYDRATOR = /\\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;\n\nconst regexps: Partial<Record<StyleBucketName, RegExp>> = {\n  k: KEYFRAMES_HYDRATOR,\n  t: AT_RULES_HYDRATOR,\n  m: AT_RULES_HYDRATOR,\n};\n\n/**\n * Should be called in a case of Server-Side rendering. Rehydrates cache from for a renderer to avoid double insertion\n * of classes to DOM.\n *\n * @public\n */\nexport function rehydrateRendererCache(\n  renderer: GriffelRenderer,\n  target: Document | undefined = typeof document === 'undefined' ? undefined : document,\n) {\n  if (target) {\n    const styleElements = target.querySelectorAll<HTMLStyleElement>('[data-make-styles-bucket]');\n\n    styleElements.forEach(styleElement => {\n      const bucketName = styleElement.dataset['makeStylesBucket'] as StyleBucketName;\n      const regex = regexps[bucketName] || STYLES_HYDRATOR;\n\n      const stylesheetKey = bucketName === 'm' ? bucketName + styleElement.media : bucketName;\n\n      // ðŸ‘‡ If some elements are not created yet, we will register them in renderer\n      if (!renderer.stylesheets[stylesheetKey]) {\n        renderer.stylesheets[stylesheetKey] = createIsomorphicStyleSheetFromElement(styleElement);\n      }\n\n      let match;\n      while ((match = regex.exec(styleElement.textContent!))) {\n        // \"cacheKey\" is either a class name or an animation name\n        const [cssRule] = match;\n\n        renderer.insertionCache[cssRule] = bucketName;\n\n        if (process.env.NODE_ENV !== 'production' && isDevToolsEnabled) {\n          debugData.addCSSRule(cssRule);\n        }\n      }\n    });\n  }\n}\n"],"names":["KEYFRAMES_HYDRATOR","AT_RULES_HYDRATOR","STYLES_HYDRATOR","regexps","k","t","m","rehydrateRendererCache","renderer","target","document","undefined","styleElements","querySelectorAll","forEach","styleElement","bucketName","dataset","regex","stylesheetKey","media","stylesheets","createIsomorphicStyleSheetFromElement","match","exec","textContent","cssRule","insertionCache","process","env","NODE_ENV","isDevToolsEnabled","debugData","addCSSRule"],"mappings":";;;;;AAIA;AACA;AACA,MAAMA,kBAAkB,GAAG,+EAA+E;AAC1G,MAAMC,iBAAiB,GAAG,gDAAgD;AAC1E,MAAMC,eAAe,GAAG,2CAA2C;AAEnE,MAAMC,OAAO,GAA6C;EACxDC,CAAC,EAAEJ,kBAAkB;EACrBK,CAAC,EAAEJ,iBAAiB;EACpBK,CAAC,EAAEL;CACJ;AAED;;;;;;SAMgBM,sBAAsB,CACpCC,QAAyB,EACzBC,SAA+B,OAAOC,QAAQ,KAAK,WAAW,GAAGC,SAAS,GAAGD,QAAQ;EAErF,IAAID,MAAM,EAAE;IACV,MAAMG,aAAa,GAAGH,MAAM,CAACI,gBAAgB,CAAmB,2BAA2B,CAAC;IAE5FD,aAAa,CAACE,OAAO,CAACC,YAAY;MAChC,MAAMC,UAAU,GAAGD,YAAY,CAACE,OAAO,CAAC,kBAAkB,CAAoB;MAC9E,MAAMC,KAAK,GAAGf,OAAO,CAACa,UAAU,CAAC,IAAId,eAAe;MAEpD,MAAMiB,aAAa,GAAGH,UAAU,KAAK,GAAG,GAAGA,UAAU,GAAGD,YAAY,CAACK,KAAK,GAAGJ,UAAU;;MAGvF,IAAI,CAACR,QAAQ,CAACa,WAAW,CAACF,aAAa,CAAC,EAAE;QACxCX,QAAQ,CAACa,WAAW,CAACF,aAAa,CAAC,GAAGG,qCAAqC,CAACP,YAAY,CAAC;;MAG3F,IAAIQ,KAAK;MACT,OAAQA,KAAK,GAAGL,KAAK,CAACM,IAAI,CAACT,YAAY,CAACU,WAAY,CAAC,EAAG;;QAEtD,MAAM,CAACC,OAAO,CAAC,GAAGH,KAAK;QAEvBf,QAAQ,CAACmB,cAAc,CAACD,OAAO,CAAC,GAAGV,UAAU;QAE7C,IAAIY,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAIC,iBAAiB,EAAE;UAC9DC,SAAS,CAACC,UAAU,CAACP,OAAO,CAAC;;;KAGlC,CAAC;;AAEN;;;;"}