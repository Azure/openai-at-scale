{"version":3,"file":"reduceToClassNameForSlots.cjs.js","sources":["../../../../packages/core/src/runtime/reduceToClassNameForSlots.ts"],"sourcesContent":["import { DEFINITION_LOOKUP_TABLE } from '../constants';\nimport { hashSequence } from './utils/hashSequence';\nimport { CSSClassesMapBySlot, CSSClassesMap, CSSClasses } from '../types';\n\n/**\n * Reduces a classname map for slot to a classname string. Uses classnames according to text directions.\n *\n * @private\n */\nexport function reduceToClassName(classMap: CSSClassesMap, dir: 'ltr' | 'rtl'): string {\n  let className = '';\n\n  // eslint-disable-next-line guard-for-in\n  for (const propertyHash in classMap) {\n    const classNameMapping: CSSClasses = classMap[propertyHash];\n\n    if (classNameMapping) {\n      const hasRTLClassName = Array.isArray(classNameMapping);\n\n      if (dir === 'rtl') {\n        className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + ' ';\n      } else {\n        className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + ' ';\n      }\n    }\n  }\n\n  return className.slice(0, -1);\n}\n\n/**\n * Reduces classname maps for slots to classname strings. Registers them in a definition cache to be used by\n * `mergeClasses()`.\n *\n * @internal\n */\nexport function reduceToClassNameForSlots<Slots extends string | number>(\n  classesMapBySlot: CSSClassesMapBySlot<Slots>,\n  dir: 'ltr' | 'rtl',\n): Record<Slots, string> {\n  const classNamesForSlots = {} as Record<Slots, string>;\n\n  // eslint-disable-next-line guard-for-in\n  for (const slotName in classesMapBySlot) {\n    const slotClasses = reduceToClassName(classesMapBySlot[slotName], dir);\n\n    // Handles a case when there are no classes in a set i.e. \"makeStyles({ root: {} })\"\n    if (slotClasses === '') {\n      classNamesForSlots[slotName] = '';\n      continue;\n    }\n\n    const sequenceHash = hashSequence(slotClasses, dir);\n    const resultSlotClasses = sequenceHash + ' ' + slotClasses;\n\n    DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];\n    classNamesForSlots[slotName] = resultSlotClasses;\n  }\n\n  return classNamesForSlots;\n}\n"],"names":["reduceToClassName","classMap","dir","className","propertyHash","classNameMapping","hasRTLClassName","Array","isArray","slice","reduceToClassNameForSlots","classesMapBySlot","classNamesForSlots","slotName","slotClasses","sequenceHash","hashSequence","resultSlotClasses","DEFINITION_LOOKUP_TABLE"],"mappings":";;;;;;;AAIA;;;;;SAKgBA,iBAAiB,CAACC,QAAuB,EAAEC,GAAkB;EAC3E,IAAIC,SAAS,GAAG,EAAE;;EAGlB,KAAK,MAAMC,YAAY,IAAIH,QAAQ,EAAE;IACnC,MAAMI,gBAAgB,GAAeJ,QAAQ,CAACG,YAAY,CAAC;IAE3D,IAAIC,gBAAgB,EAAE;MACpB,MAAMC,eAAe,GAAGC,KAAK,CAACC,OAAO,CAACH,gBAAgB,CAAC;MAEvD,IAAIH,GAAG,KAAK,KAAK,EAAE;QACjBC,SAAS,IAAI,CAACG,eAAe,GAAGD,gBAAgB,CAAC,CAAC,CAAC,GAAGA,gBAAgB,IAAI,GAAG;OAC9E,MAAM;QACLF,SAAS,IAAI,CAACG,eAAe,GAAGD,gBAAgB,CAAC,CAAC,CAAC,GAAGA,gBAAgB,IAAI,GAAG;;;;EAKnF,OAAOF,SAAS,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC/B;AAEA;;;;;;SAMgBC,yBAAyB,CACvCC,gBAA4C,EAC5CT,GAAkB;EAElB,MAAMU,kBAAkB,GAAG,EAA2B;;EAGtD,KAAK,MAAMC,QAAQ,IAAIF,gBAAgB,EAAE;IACvC,MAAMG,WAAW,GAAGd,iBAAiB,CAACW,gBAAgB,CAACE,QAAQ,CAAC,EAAEX,GAAG,CAAC;;IAGtE,IAAIY,WAAW,KAAK,EAAE,EAAE;MACtBF,kBAAkB,CAACC,QAAQ,CAAC,GAAG,EAAE;MACjC;;IAGF,MAAME,YAAY,GAAGC,yBAAY,CAACF,WAAW,EAAEZ,GAAG,CAAC;IACnD,MAAMe,iBAAiB,GAAGF,YAAY,GAAG,GAAG,GAAGD,WAAW;IAE1DI,iCAAuB,CAACH,YAAY,CAAC,GAAG,CAACJ,gBAAgB,CAACE,QAAQ,CAAC,EAAEX,GAAG,CAAC;IACzEU,kBAAkB,CAACC,QAAQ,CAAC,GAAGI,iBAAiB;;EAGlD,OAAOL,kBAAkB;AAC3B;;;;;"}